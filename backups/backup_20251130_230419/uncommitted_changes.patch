diff --git a/backend/.env.example b/backend/.env.example
index d9b1583..4a9366f 100644
--- a/backend/.env.example
+++ b/backend/.env.example
@@ -1,9 +1,21 @@
 # Database Configuration
-DATABASE_URL=postgresql://aigovernance:password123@localhost:5432/aigovernance_db
+DATABASE_URL=postgresql://aigovernance:password123@postgres:5432/aigovernance_db
 
 # API Configuration
 API_KEY_SECRET=your-secret-key-change-this-in-production
-ALLOWED_ORIGINS=http://localhost:3000,http://localhost:5173
+
+# CORS Configuration (Allowed Frontend Origins)
+# UPDATE THIS when ngrok URLs change or add new frontend URLs
+# Format: comma-separated list of URLs
+# Examples:
+#   Development: http://localhost:5173,http://localhost:3000
+#   Production with ngrok: https://YOUR-NGROK-URL.ngrok-free.dev,http://localhost:5173
+CORS_ORIGINS=https://surrey-tide-neutral-presence.trycloudflare.com,http://localhost:5173
+ALLOWED_ORIGINS=https://surrey-tide-neutral-presence.trycloudflare.com,http://localhost:5173
+
+# Auth0 Configuration
+AUTH0_DOMAIN=dev-y75lecimhanaeqy7.us.auth0.com
+AUTH0_API_AUDIENCE=https://blah-subsequent-personal-synthetic.trycloudflare.com
 
 # Server Configuration
 HOST=0.0.0.0
diff --git a/backend/README.md b/backend/README.md
index c56ad4e..41796b6 100644
--- a/backend/README.md
+++ b/backend/README.md
@@ -24,10 +24,10 @@ cp .env.example .env
 docker-compose up -d
 
 # Check if running
-curl http://localhost:8000/health
+curl https://blah-subsequent-personal-synthetic.trycloudflare.com/health
 ```
 
-The API will be available at `http://localhost:8000`
+The API will be available at `https://blah-subsequent-personal-synthetic.trycloudflare.com`
 
 #### Option B: Manual Setup
 
@@ -66,8 +66,8 @@ Tables are created automatically on first run. Schema includes:
 ### 4. API Documentation
 
 Once running, visit:
-- Swagger UI: `http://localhost:8000/docs`
-- ReDoc: `http://localhost:8000/redoc`
+- Swagger UI: `https://blah-subsequent-personal-synthetic.trycloudflare.com/docs`
+- ReDoc: `https://blah-subsequent-personal-synthetic.trycloudflare.com/redoc`
 
 ### 5. Testing the API
 
@@ -76,7 +76,7 @@ Once running, visit:
 export API_KEY="dev-secret-key-change-in-production"
 
 # Create a usage log
-curl -X POST http://localhost:8000/usage-logs/ \
+curl -X POST https://blah-subsequent-personal-synthetic.trycloudflare.com/usage-logs/ \
   -H "X-API-Key: $API_KEY" \
   -H "Content-Type: application/json" \
   -d '{
@@ -87,13 +87,13 @@ curl -X POST http://localhost:8000/usage-logs/ \
   }'
 
 # Get usage analytics
-curl http://localhost:8000/analytics/usage?days=7 \
+curl https://blah-subsequent-personal-synthetic.trycloudflare.com/analytics/usage?days=7 \
   -H "X-API-Key: $API_KEY"
 ```
 
 ### 6. Connecting from Browser Extension
 
-Extension should send requests to `http://localhost:8000` with header:
+Extension should send requests to `https://blah-subsequent-personal-synthetic.trycloudflare.com` with header:
 ```
 X-API-Key: dev-secret-key-change-in-production
 ```
@@ -304,7 +304,7 @@ When users type a prompt in the browser extension:
 ### Example API Call
 
 ```bash
-curl "http://localhost:8000/prompt-variants/?original_prompt=make%20this%20better" \
+curl "https://blah-subsequent-personal-synthetic.trycloudflare.com/prompt-variants/?original_prompt=make%20this%20better" \
   -H "X-API-Key: dev-secret-key-change-in-production"
 ```
 
diff --git a/backend/app/api/routes/analytics.py b/backend/app/api/routes/analytics.py
index 77108e7..5a21c8e 100644
--- a/backend/app/api/routes/analytics.py
+++ b/backend/app/api/routes/analytics.py
@@ -2,16 +2,15 @@
 Analytics API endpoints.
 Provides aggregated statistics for dashboard.
 """
-from fastapi import APIRouter, Depends, Query
+from fastapi import APIRouter, Depends, Query, HTTPException, status
 from sqlalchemy.orm import Session
 from sqlalchemy import func, desc
 from datetime import datetime, timedelta
 from typing import Optional
 
-from ...models.database import UsageLog, PromptLog, User
+from ...models.database import UsageLog, PromptLog, User, UserRole, get_db
 from ...models.schemas import UsageStats, PromptImprovementStats
-from ...core.security import verify_api_key
-from .usage import get_db
+from ...core.security import get_current_user
 
 router = APIRouter(prefix="/analytics", tags=["analytics"])
 
@@ -20,59 +19,83 @@ router = APIRouter(prefix="/analytics", tags=["analytics"])
 async def get_usage_analytics(
     days: int = Query(7, description="Number of days to analyze", ge=1, le=365),
     db: Session = Depends(get_db),
-    api_key: str = Depends(verify_api_key)
+    current_user: User = Depends(get_current_user)
 ):
     """
-    Get usage analytics
-    
-    Returns aggregated statistics on AI tool usage.
+    Get usage analytics with role-based filtering.
+
+    Returns aggregated statistics on AI tool usage based on user permissions.
+
+    Permissions:
+    - Security Team: See all organization data
+    - Team Lead: See own team data
+    - Employee: See only own data
     """
     # Calculate date range
     cutoff_date = datetime.utcnow() - timedelta(days=days)
-    
-    # Total prompts
+
+    # Get accessible user IDs based on role
+    if current_user.role == UserRole.SECURITY_TEAM:
+        accessible_ids = db.query(User.id).filter(
+            User.org_id == current_user.org_id
+        ).all()
+        accessible_ids = [uid[0] for uid in accessible_ids]
+    elif current_user.role == UserRole.TEAM_LEAD and current_user.team_id:
+        accessible_ids = db.query(User.id).filter(
+            User.team_id == current_user.team_id
+        ).all()
+        accessible_ids = [uid[0] for uid in accessible_ids]
+    else:  # Employee
+        accessible_ids = [current_user.id]
+
+    # Total prompts (filtered by accessible users)
     total_prompts = db.query(UsageLog).filter(
+        UsageLog.user_id.in_(accessible_ids),
         UsageLog.timestamp >= cutoff_date
     ).count()
-    
-    # Unique users - ADD THIS
+
+    # Unique users (filtered by accessible users)
     unique_users = db.query(func.count(func.distinct(UsageLog.user_id))).filter(
+        UsageLog.user_id.in_(accessible_ids),
         UsageLog.timestamp >= cutoff_date
     ).scalar() or 0
-    
-    # Prompts by tool
+
+    # Prompts by tool (filtered by accessible users)
     prompts_by_tool_data = db.query(
         UsageLog.tool,
         func.count(UsageLog.id).label('count')
     ).filter(
+        UsageLog.user_id.in_(accessible_ids),
         UsageLog.timestamp >= cutoff_date
     ).group_by(UsageLog.tool).all()
-    
+
     prompts_by_tool = {tool: count for tool, count in prompts_by_tool_data}
-    
-    # Prompts by risk level
+
+    # Prompts by risk level (filtered by accessible users)
     prompts_by_risk_data = db.query(
         UsageLog.risk_level,
         func.count(UsageLog.id).label('count')
     ).filter(
+        UsageLog.user_id.in_(accessible_ids),
         UsageLog.timestamp >= cutoff_date
     ).group_by(UsageLog.risk_level).all()
-    
+
     prompts_by_risk = {risk.value: count for risk, count in prompts_by_risk_data}
-    
-    # Top users
+
+    # Top users (filtered by accessible users)
     top_users_data = db.query(
         User.email,
         func.count(UsageLog.id).label('count')
     ).join(UsageLog).filter(
+        UsageLog.user_id.in_(accessible_ids),
         UsageLog.timestamp >= cutoff_date
     ).group_by(User.email).order_by(desc('count')).limit(10).all()
-    
+
     top_users = [{"email": email, "count": count} for email, count in top_users_data]
-    
+
     return UsageStats(
         total_prompts=total_prompts,
-        unique_users=unique_users, 
+        unique_users=unique_users,
         prompts_by_tool=prompts_by_tool,
         prompts_by_risk=prompts_by_risk,
         top_users=top_users
@@ -83,53 +106,77 @@ async def get_usage_analytics(
 async def get_prompt_improvement_stats(
     days: int = Query(7, description="Number of days to analyze", ge=1, le=365),
     db: Session = Depends(get_db),
-    api_key: str = Depends(verify_api_key)
+    current_user: User = Depends(get_current_user)
 ):
     """
-    Get prompt improvement statistics
-    
-    Returns statistics on prompt variant adoption and improvements.
+    Get prompt improvement statistics with role-based filtering.
+
+    Returns statistics on prompt variant adoption and improvements based on user permissions.
+
+    Permissions:
+    - Security Team: See all organization data
+    - Team Lead: See own team data
+    - Employee: See only own data
     """
     cutoff_date = datetime.utcnow() - timedelta(days=days)
-    
-    # Total suggestions offered
+
+    # Get accessible user IDs based on role
+    if current_user.role == UserRole.SECURITY_TEAM:
+        accessible_ids = db.query(User.id).filter(
+            User.org_id == current_user.org_id
+        ).all()
+        accessible_ids = [uid[0] for uid in accessible_ids]
+    elif current_user.role == UserRole.TEAM_LEAD and current_user.team_id:
+        accessible_ids = db.query(User.id).filter(
+            User.team_id == current_user.team_id
+        ).all()
+        accessible_ids = [uid[0] for uid in accessible_ids]
+    else:  # Employee
+        accessible_ids = [current_user.id]
+
+    # Total suggestions offered (filtered by accessible users)
     total_suggestions = db.query(PromptLog).filter(
+        PromptLog.user_id.in_(accessible_ids),
         PromptLog.timestamp >= cutoff_date
     ).count()
-    
-    # Variants chosen (variant_index >= 0 means a variant was chosen)
+
+    # Variants chosen (filtered by accessible users)
     variants_chosen = db.query(PromptLog).filter(
+        PromptLog.user_id.in_(accessible_ids),
         PromptLog.timestamp >= cutoff_date,
         PromptLog.variant_index >= 0
     ).count()
-    
-    # Originals kept (variant_index == -1 means original was kept)
+
+    # Originals kept (filtered by accessible users)
     originals_kept = db.query(PromptLog).filter(
+        PromptLog.user_id.in_(accessible_ids),
         PromptLog.timestamp >= cutoff_date,
         PromptLog.variant_index == -1
     ).count()
-    
+
     # Adoption rate
     adoption_rate = (variants_chosen / total_suggestions) if total_suggestions > 0 else 0
-    
-    # Average improvement score
+
+    # Average improvement score (filtered by accessible users)
     avg_improvement = db.query(func.avg(PromptLog.improvement_score)).filter(
+        PromptLog.user_id.in_(accessible_ids),
         PromptLog.timestamp >= cutoff_date,
         PromptLog.improvement_score.isnot(None)
     ).scalar() or 0.0
-    
-    # Top improvements (prompts with highest improvement scores)
+
+    # Top improvements (filtered by accessible users)
     top_improvements_data = db.query(
         PromptLog.original_prompt,
         PromptLog.chosen_variant,
         PromptLog.improvement_score
     ).filter(
+        PromptLog.user_id.in_(accessible_ids),
         PromptLog.timestamp >= cutoff_date,
         PromptLog.improvement_score.isnot(None)
     ).order_by(
         desc(PromptLog.improvement_score)
     ).limit(10).all()
-    
+
     top_improvements = [
         {
             "original": original[:100] + "..." if len(original) > 100 else original,
@@ -138,12 +185,12 @@ async def get_prompt_improvement_stats(
         }
         for original, chosen, score in top_improvements_data
     ]
-    
+
     return PromptImprovementStats(
         total_suggestions=total_suggestions,
         variants_chosen=variants_chosen,
-        originals_kept=originals_kept,  # ADD THIS
+        originals_kept=originals_kept,
         adoption_rate=adoption_rate,
-        avg_improvement=float(avg_improvement),  # ADD THIS
-        top_improvements=top_improvements  # ADD THIS
+        avg_improvement=float(avg_improvement),
+        top_improvements=top_improvements
     )
diff --git a/backend/app/api/routes/policies.py b/backend/app/api/routes/policies.py
index fc7f6ff..f62673d 100644
--- a/backend/app/api/routes/policies.py
+++ b/backend/app/api/routes/policies.py
@@ -2,14 +2,14 @@
 Policies API endpoints.
 Manages organization-level AI usage policies.
 """
-from fastapi import APIRouter, Depends, HTTPException, Query
+from fastapi import APIRouter, Depends, HTTPException, Query, status
 from sqlalchemy.orm import Session
 from typing import List, Optional
+from datetime import datetime, timedelta
 
-from ...models.database import Policy, Alert, User
+from ...models.database import Policy, Alert, User, get_db
 from ...models.schemas import PolicyCreate, PolicyResponse, AlertCreate, AlertResponse
-from ...core.security import verify_api_key
-from .usage import get_db
+from ...core.security import get_current_user, require_role
 
 router = APIRouter(tags=["policies"])
 
@@ -18,7 +18,7 @@ router = APIRouter(tags=["policies"])
 async def create_policy(
     policy_data: PolicyCreate,
     db: Session = Depends(get_db),
-    api_key: str = Depends(verify_api_key)
+    current_user: dict = require_role(["admin"])
 ):
     """
     Create a new policy for an organization.
@@ -31,8 +31,8 @@ async def create_policy(
     Args:
         policy_data: Policy configuration
         db: Database session
-        api_key: Validated API key
-        
+        current_user: Current user (admin required)
+
     Returns:
         Created policy record
     """
@@ -53,24 +53,40 @@ async def create_policy(
 async def get_policies(
     org_id: int,
     db: Session = Depends(get_db),
-    api_key: str = Depends(verify_api_key)
+    current_user: dict = Depends(get_current_user)
 ):
     """
     Retrieve all policies for an organization.
-    
-    Extension calls this on startup to cache policies locally.
-    
+
+    Users can only view their own org's policies.
+
     Args:
         org_id: Organization ID
         db: Database session
-        api_key: Validated API key
-        
+        current_user: Current authenticated user
+
     Returns:
         List of active policies
     """
+    # Verify user has access to this org
+    requesting_user = db.query(User).filter(
+        User.email == current_user.email
+    ).first()
+
+    if not requesting_user:
+        raise HTTPException(
+            status_code=status.HTTP_404_NOT_FOUND,
+            detail="User not found"
+        )
+
+    if requesting_user.org_id != org_id:
+        raise HTTPException(
+            status_code=status.HTTP_403_FORBIDDEN,
+            detail="You can only view your own organization's policies"
+        )
     policies = db.query(Policy).filter(
         Policy.org_id == org_id,
-        Policy.active == True
+        Policy.is_active == True
     ).all()
     
     return policies
@@ -80,28 +96,40 @@ async def get_policies(
 async def create_alert(
     alert_data: AlertCreate,
     db: Session = Depends(get_db),
-    api_key: str = Depends(verify_api_key)
+    current_user: dict = Depends(get_current_user)
 ):
     """
     Create a compliance alert.
-    
-    Called by extension when:
+
+    Called when:
     - PII detected in prompt
     - User attempts blocked AI tool
     - Rate limit exceeded
-    
+
+    User can only create alerts for themselves.
+
     Args:
         alert_data: Alert details
         db: Database session
-        api_key: Validated API key
-        
+        current_user: Current authenticated user
+
     Returns:
         Created alert record
     """
-    # Find user
-    user = db.query(User).filter(User.email == alert_data.user_email).first()
+    # Only allow creating alerts for authenticated user
+    if alert_data.user_email != current_user.email:
+        raise HTTPException(
+            status_code=status.HTTP_403_FORBIDDEN,
+            detail="You can only create alerts for yourself"
+        )
+
+    # Find or create user
+    user = db.query(User).filter(User.email == current_user.email).first()
     if not user:
-        raise HTTPException(status_code=404, detail="User not found")
+        raise HTTPException(
+            status_code=status.HTTP_404_NOT_FOUND,
+            detail="User not found. Please register first."
+        )
     
     # Create alert
     alert = Alert(
@@ -122,35 +150,50 @@ async def get_alerts(
     resolved: Optional[bool] = Query(None, description="Filter by resolution status"),
     days: int = Query(7, description="Number of days to look back"),
     db: Session = Depends(get_db),
-    api_key: str = Depends(verify_api_key)
+    current_user: dict = Depends(get_current_user)
 ):
     """
     Retrieve alerts for dashboard.
-    
+
+    Users see only their own alerts. Admins can see all alerts.
+
     Args:
         resolved: Filter by resolution status (None = all)
         days: How many days of history
         db: Database session
-        api_key: Validated API key
-        
+        current_user: Current authenticated user
+
     Returns:
         List of alerts
     """
-    from datetime import datetime, timedelta
-    
+    # Get requesting user
+    requesting_user = db.query(User).filter(
+        User.email == current_user.email
+    ).first()
+
+    if not requesting_user:
+        raise HTTPException(
+            status_code=status.HTTP_404_NOT_FOUND,
+            detail="User not found"
+        )
+
     query = db.query(Alert)
-    
+
     # Time filter
     start_date = datetime.utcnow() - timedelta(days=days)
     query = query.filter(Alert.timestamp >= start_date)
-    
+
+    # Only show user's own alerts unless admin
+    if requesting_user.role != "admin":
+        query = query.filter(Alert.user_id == requesting_user.id)
+
     # Resolution filter
     if resolved is not None:
         query = query.filter(Alert.resolved == resolved)
-    
+
     # Most recent first
     alerts = query.order_by(Alert.timestamp.desc()).limit(1000).all()
-    
+
     return alerts
 
 
@@ -158,24 +201,48 @@ async def get_alerts(
 async def resolve_alert(
     alert_id: int,
     db: Session = Depends(get_db),
-    api_key: str = Depends(verify_api_key)
+    current_user: dict = Depends(get_current_user)
 ):
     """
     Mark an alert as resolved.
-    
+
+    Users can only resolve their own alerts. Admins can resolve any alert.
+
     Args:
         alert_id: Alert ID to resolve
         db: Database session
-        api_key: Validated API key
-        
+        current_user: Current authenticated user
+
     Returns:
         Success message
     """
+    # Get alert
     alert = db.query(Alert).filter(Alert.id == alert_id).first()
     if not alert:
-        raise HTTPException(status_code=404, detail="Alert not found")
-    
+        raise HTTPException(
+            status_code=status.HTTP_404_NOT_FOUND,
+            detail="Alert not found"
+        )
+
+    # Get requesting user
+    requesting_user = db.query(User).filter(
+        User.email == current_user.email
+    ).first()
+
+    if not requesting_user:
+        raise HTTPException(
+            status_code=status.HTTP_404_NOT_FOUND,
+            detail="User not found"
+        )
+
+    # Check permissions
+    if requesting_user.role != "admin" and requesting_user.id != alert.user_id:
+        raise HTTPException(
+            status_code=status.HTTP_403_FORBIDDEN,
+            detail="You can only resolve your own alerts"
+        )
+
     alert.resolved = True
     db.commit()
-    
+
     return {"message": "Alert resolved"}
diff --git a/backend/app/api/routes/prompt_history.py b/backend/app/api/routes/prompt_history.py
index 6843edf..3d081bf 100644
--- a/backend/app/api/routes/prompt_history.py
+++ b/backend/app/api/routes/prompt_history.py
@@ -1,23 +1,21 @@
 """
 Prompt History API Routes
-Create: backend/app/api/routes/prompt_history.py
 """
 
-from fastapi import APIRouter, Depends, HTTPException, Query
+from fastapi import APIRouter, Depends, HTTPException, Query, status
 from sqlalchemy.orm import Session
 from sqlalchemy import func, desc
 from typing import List, Optional
 from datetime import datetime, timedelta
 
-from ...models.database import PromptHistory, User
+from ...models.database import PromptHistory, User, get_db
 from ...models.schemas import (
-    PromptHistoryCreate, 
+    PromptHistoryCreate,
     PromptHistoryResponse,
     PromptHistoryListResponse,
     PromptHistoryStats
 )
-from ...core.security import verify_api_key
-from ..routes.usage import get_db
+from ...core.security import get_current_user
 
 router = APIRouter(prefix="/prompt-history", tags=["Prompt History"])
 
@@ -26,17 +24,17 @@ router = APIRouter(prefix="/prompt-history", tags=["Prompt History"])
 async def create_prompt_history(
     history_data: PromptHistoryCreate,
     db: Session = Depends(get_db),
-    api_key: str = Depends(verify_api_key)
+    current_user: dict = Depends(get_current_user)
 ):
     """
-    Create a new prompt history entry
-    
+    Create a new prompt history entry.
+
     Logs complete prompt details including:
     - Original and final prompts
     - Variants offered and selected
     - Quality scores and improvements
     - PII detection results
-    
+
     **Example:**
     ```json
     {
@@ -51,12 +49,21 @@ async def create_prompt_history(
     }
     ```
     """
+    # Verify requesting user email matches
+    if history_data.user_email != current_user.email:
+        raise HTTPException(
+            status_code=status.HTTP_403_FORBIDDEN,
+            detail="You can only create history for yourself"
+        )
+
     # Find or create user
-    user = db.query(User).filter(User.email == history_data.user_email).first()
+    user = db.query(User).filter(User.email == current_user.email).first()
     if not user:
         user = User(
-            email=history_data.user_email,
-            org_id=1,
+            email=current_user.email,
+            name=current_user.get("name"),
+            picture=current_user.get("picture"),
+            org_id=current_user.get("org_id", 1),
             role="employee"
         )
         db.add(user)
@@ -93,14 +100,14 @@ async def create_prompt_history(
 
 @router.get("/", response_model=PromptHistoryListResponse)
 async def get_prompt_history(
-    user_email: Optional[str] = Query(None, description="Filter by user email"),
+    user_email: Optional[str] = Query(None, description="Filter by user email (admin only)"),
     tool: Optional[str] = Query(None, description="Filter by AI tool"),
     had_pii: Optional[bool] = Query(None, description="Filter by PII presence"),
     days: int = Query(30, description="Number of days to look back", ge=1, le=365),
     page: int = Query(1, description="Page number", ge=1),
     page_size: int = Query(50, description="Items per page", ge=1, le=100),
     db: Session = Depends(get_db),
-    api_key: str = Depends(verify_api_key)
+    current_user: dict = Depends(get_current_user)
 ):
     """
     Get prompt history with filters and pagination
@@ -120,20 +127,41 @@ async def get_prompt_history(
     GET /prompt-history/?user_email=john@company.com&tool=chatgpt&page=1&page_size=20
     ```
     """
+    # Get requesting user
+    requesting_user = db.query(User).filter(
+        User.email == current_user.email
+    ).first()
+
+    if not requesting_user:
+        raise HTTPException(
+            status_code=status.HTTP_404_NOT_FOUND,
+            detail="User not found"
+        )
+
     # Build query
     query = db.query(PromptHistory)
-    
+
     # Date filter
     cutoff_date = datetime.utcnow() - timedelta(days=days)
     query = query.filter(PromptHistory.timestamp >= cutoff_date)
-    
-    # User filter
-    if user_email:
-        user = db.query(User).filter(User.email == user_email).first()
-        if user:
-            query = query.filter(PromptHistory.user_id == user.id)
-        else:
+
+    # User filter - determine which user's history to retrieve
+    filter_user_id = requesting_user.id
+
+    if user_email and user_email != current_user.email:
+        # Only admins can view other users' history
+        if requesting_user.role != "admin":
+            raise HTTPException(
+                status_code=status.HTTP_403_FORBIDDEN,
+                detail="You can only view your own history"
+            )
+        # Find the requested user
+        target_user = db.query(User).filter(User.email == user_email).first()
+        if not target_user:
             return PromptHistoryListResponse(total=0, page=page, page_size=page_size, items=[])
+        filter_user_id = target_user.id
+
+    query = query.filter(PromptHistory.user_id == filter_user_id)
     
     # Tool filter
     if tool:
@@ -160,10 +188,10 @@ async def get_prompt_history(
 
 @router.get("/stats", response_model=PromptHistoryStats)
 async def get_prompt_history_stats(
-    user_email: Optional[str] = Query(None, description="Filter by user email"),
+    user_email: Optional[str] = Query(None, description="Filter by user email (admin only)"),
     days: int = Query(30, description="Number of days to look back", ge=1, le=365),
     db: Session = Depends(get_db),
-    api_key: str = Depends(verify_api_key)
+    current_user: dict = Depends(get_current_user)
 ):
     """
     Get prompt history statistics
@@ -191,16 +219,38 @@ async def get_prompt_history_stats(
     }
     ```
     """
+    # Get requesting user
+    requesting_user = db.query(User).filter(
+        User.email == current_user.email
+    ).first()
+
+    if not requesting_user:
+        raise HTTPException(
+            status_code=status.HTTP_404_NOT_FOUND,
+            detail="User not found"
+        )
+
     # Build base query
     query = db.query(PromptHistory)
     cutoff_date = datetime.utcnow() - timedelta(days=days)
     query = query.filter(PromptHistory.timestamp >= cutoff_date)
-    
-    # User filter
-    if user_email:
+
+    # User filter - determine which user's stats to retrieve
+    filter_user_id = requesting_user.id
+
+    if user_email and user_email != current_user.email:
+        # Only admins can view other users' stats
+        if requesting_user.role != "admin":
+            raise HTTPException(
+                status_code=status.HTTP_403_FORBIDDEN,
+                detail="You can only view your own stats"
+            )
+        # Find the requested user
         user = db.query(User).filter(User.email == user_email).first()
         if user:
-            query = query.filter(PromptHistory.user_id == user.id)
+            filter_user_id = user.id
+
+    query = query.filter(PromptHistory.user_id == filter_user_id)
     
     # Total prompts
     total_prompts = query.count()
@@ -250,18 +300,39 @@ async def get_prompt_history_stats(
 async def get_prompt_history_detail(
     history_id: int,
     db: Session = Depends(get_db),
-    api_key: str = Depends(verify_api_key)
+    current_user: dict = Depends(get_current_user)
 ):
     """
     Get a specific prompt history entry by ID
     
     Returns full details including all variants offered.
     """
+    # Get requesting user
+    requesting_user = db.query(User).filter(
+        User.email == current_user.email
+    ).first()
+
+    if not requesting_user:
+        raise HTTPException(
+            status_code=status.HTTP_404_NOT_FOUND,
+            detail="User not found"
+        )
+
     history = db.query(PromptHistory).filter(PromptHistory.id == history_id).first()
-    
+
     if not history:
-        raise HTTPException(status_code=404, detail="Prompt history not found")
-    
+        raise HTTPException(
+            status_code=status.HTTP_404_NOT_FOUND,
+            detail="Prompt history not found"
+        )
+
+    # Check permissions - users can only view their own, admins can view all
+    if requesting_user.role != "admin" and requesting_user.id != history.user_id:
+        raise HTTPException(
+            status_code=status.HTTP_403_FORBIDDEN,
+            detail="You can only view your own history"
+        )
+
     return history
 
 
@@ -269,19 +340,42 @@ async def get_prompt_history_detail(
 async def delete_prompt_history(
     history_id: int,
     db: Session = Depends(get_db),
-    api_key: str = Depends(verify_api_key)
+    current_user: dict = Depends(get_current_user)
 ):
     """
-    Delete a prompt history entry
-    
+    Delete a prompt history entry.
+
+    Users can only delete their own entries. Admins can delete any entry.
+
     Permanently removes a prompt history record. Use with caution.
     """
+    # Get requesting user
+    requesting_user = db.query(User).filter(
+        User.email == current_user.email
+    ).first()
+
+    if not requesting_user:
+        raise HTTPException(
+            status_code=status.HTTP_404_NOT_FOUND,
+            detail="User not found"
+        )
+
     history = db.query(PromptHistory).filter(PromptHistory.id == history_id).first()
-    
+
     if not history:
-        raise HTTPException(status_code=404, detail="Prompt history not found")
-    
+        raise HTTPException(
+            status_code=status.HTTP_404_NOT_FOUND,
+            detail="Prompt history not found"
+        )
+
+    # Check permissions
+    if requesting_user.role != "admin" and requesting_user.id != history.user_id:
+        raise HTTPException(
+            status_code=status.HTTP_403_FORBIDDEN,
+            detail="You can only delete your own history"
+        )
+
     db.delete(history)
     db.commit()
-    
+
     return None
diff --git a/backend/app/api/routes/prompts.py b/backend/app/api/routes/prompts.py
index f087f1e..ff772bd 100644
--- a/backend/app/api/routes/prompts.py
+++ b/backend/app/api/routes/prompts.py
@@ -1,169 +1,366 @@
 """
-Prompt variants API endpoints
-Generates improved prompt variants
+Enhanced Prompt Variants Route - Enterprise Grade
+backend/app/api/routes/prompts.py
+
+Features:
+- Handles prompts up to 10,000 characters
+- Smart chunking for long prompts
+- Context-aware improvements
+- Industry-specific templates
+- Quality scoring
+- A/B testing support
 """
-from fastapi import APIRouter, Depends, HTTPException
-from sqlalchemy.orm import Session
-from typing import List, Dict
 
-from ...models.database import PromptLog, User
-from ...models.schemas import PromptLogCreate, PromptLogResponse
-from ...core.security import verify_api_key
-from ...prompt_generation.generator import RuleBasedGenerator
-from ...prompt_generation.cache import prompt_cache
-from .usage import get_db
+from fastapi import APIRouter, Query, HTTPException
+from typing import List, Optional
+import re
+from datetime import datetime
+
+router = APIRouter(prefix="/prompt-variants", tags=["Prompts"])
+
+
+class PromptAnalyzer:
+    """Advanced prompt analysis and improvement"""
+    
+    def __init__(self):
+        self.max_length = 10000  # Support longer prompts
+        self.optimal_length_range = (50, 500)
+        
+        # Industry-specific patterns
+        self.industry_patterns = {
+            'code': r'\b(code|function|script|program|debug|implement)\b',
+            'data': r'\b(data|analyze|statistics|chart|graph|sql|query)\b',
+            'creative': r'\b(write|story|essay|article|blog|creative)\b',
+            'business': r'\b(report|presentation|analysis|strategy|proposal)\b',
+            'research': r'\b(research|study|investigate|explore|examine)\b',
+        }
+        
+        # Quality improvement patterns
+        self.improvement_patterns = {
+            'vague_words': r'\b(thing|stuff|something|anything|good|bad|nice)\b',
+            'filler_words': r'\b(really|very|actually|basically|literally)\b',
+            'passive_voice': r'\b(is|are|was|were|been|being)\s+\w+ed\b',
+        }
+    
+    def detect_industry(self, prompt: str) -> str:
+        """Detect prompt industry/domain"""
+        prompt_lower = prompt.lower()
+        
+        for industry, pattern in self.industry_patterns.items():
+            if re.search(pattern, prompt_lower):
+                return industry
+        
+        return 'general'
+    
+    def analyze_quality(self, prompt: str) -> dict:
+        """Comprehensive quality analysis"""
+        word_count = len(prompt.split())
+        char_count = len(prompt)
+        
+        # Check for issues
+        has_vague = bool(re.search(self.improvement_patterns['vague_words'], prompt.lower()))
+        has_filler = bool(re.search(self.improvement_patterns['filler_words'], prompt.lower()))
+        has_passive = bool(re.search(self.improvement_patterns['passive_voice'], prompt.lower()))
+        
+        # Check for good practices
+        has_specificity = word_count > 10
+        has_context = any(word in prompt.lower() for word in ['for', 'because', 'in order to', 'context'])
+        has_output_format = any(word in prompt.lower() for word in ['format', 'structure', 'json', 'list', 'table'])
+        has_constraints = any(word in prompt.lower() for word in ['limit', 'maximum', 'minimum', 'within', 'words'])
+        
+        # Calculate base score
+        score = 50
+        
+        # Deductions
+        if has_vague: score -= 15
+        if has_filler: score -= 10
+        if has_passive: score -= 5
+        if word_count < 5: score -= 20
+        if char_count > 2000: score -= 10  # Too long
+        
+        # Bonuses
+        if has_specificity: score += 10
+        if has_context: score += 15
+        if has_output_format: score += 10
+        if has_constraints: score += 10
+        
+        return {
+            'score': max(0, min(100, score)),
+            'word_count': word_count,
+            'char_count': char_count,
+            'issues': {
+                'vague_language': has_vague,
+                'filler_words': has_filler,
+                'passive_voice': has_passive,
+            },
+            'strengths': {
+                'has_specificity': has_specificity,
+                'has_context': has_context,
+                'has_output_format': has_output_format,
+                'has_constraints': has_constraints,
+            }
+        }
+    
+    def chunk_long_prompt(self, prompt: str, max_chunk_size: int = 2000) -> List[str]:
+        """Smart chunking for long prompts"""
+        if len(prompt) <= max_chunk_size:
+            return [prompt]
+        
+        chunks = []
+        sentences = re.split(r'(?<=[.!?])\s+', prompt)
+        
+        current_chunk = ""
+        for sentence in sentences:
+            if len(current_chunk) + len(sentence) <= max_chunk_size:
+                current_chunk += sentence + " "
+            else:
+                if current_chunk:
+                    chunks.append(current_chunk.strip())
+                current_chunk = sentence + " "
+        
+        if current_chunk:
+            chunks.append(current_chunk.strip())
+        
+        return chunks
+    
+    def generate_variants(self, prompt: str, context: str = "general") -> List[dict]:
+        """Generate improved variants with advanced strategies"""
+        
+        analysis = self.analyze_quality(prompt)
+        industry = self.detect_industry(prompt)
+        
+        # For very long prompts, provide summary guidance
+        if len(prompt) > 5000:
+            return self._generate_long_prompt_variants(prompt, analysis, industry)
+        
+        variants = []
+        
+        # Variant 1: Add Structure & Clarity
+        variant1 = self._add_structure(prompt, industry, analysis)
+        variants.append({
+            'text': variant1,
+            'score': min(100, analysis['score'] + 25),
+            'improvements': self._get_improvements(variant1, prompt, 'structure'),
+            'strategy': 'structure_and_clarity'
+        })
+        
+        # Variant 2: Add Context & Constraints
+        variant2 = self._add_context(prompt, industry, analysis)
+        variants.append({
+            'text': variant2,
+            'score': min(100, analysis['score'] + 30),
+            'improvements': self._get_improvements(variant2, prompt, 'context'),
+            'strategy': 'context_and_constraints'
+        })
+        
+        # Variant 3: Optimize for AI (most specific)
+        variant3 = self._optimize_for_ai(prompt, industry, analysis)
+        variants.append({
+            'text': variant3,
+            'score': min(100, analysis['score'] + 35),
+            'improvements': self._get_improvements(variant3, prompt, 'ai_optimized'),
+            'strategy': 'ai_optimized'
+        })
+        
+        return variants
+    
+    def _generate_long_prompt_variants(self, prompt: str, analysis: dict, industry: str) -> List[dict]:
+        """Special handling for very long prompts (5000+ chars)"""
+        
+        # Extract key points
+        summary = self._extract_key_points(prompt)
+        
+        variants = [
+            {
+                'text': f"[LONG PROMPT - CONDENSED VERSION]\n\n{summary}\n\nNote: Original prompt was {analysis['char_count']} characters. Consider breaking into multiple focused prompts for better results.",
+                'score': 70,
+                'improvements': ['Condensed key points', 'Suggested prompt splitting', 'Maintained core intent'],
+                'strategy': 'long_prompt_summary'
+            },
+            {
+                'text': self._create_structured_long_prompt(prompt),
+                'score': 75,
+                'improvements': ['Added clear sections', 'Organized content', 'Improved readability'],
+                'strategy': 'long_prompt_structured'
+            },
+            {
+                'text': f"Break this into multiple prompts:\n\n1. {self._extract_first_goal(prompt)}\n2. [Continue with subsequent goals]\n\nTip: Submit focused prompts sequentially for best results.",
+                'score': 80,
+                'improvements': ['Sequential approach suggested', 'Better AI comprehension', 'Actionable breakdown'],
+                'strategy': 'long_prompt_sequential'
+            }
+        ]
+        
+        return variants
+    
+    def _extract_key_points(self, prompt: str) -> str:
+        """Extract key points from long prompt"""
+        # Simple extraction: first sentence + main action words
+        sentences = re.split(r'[.!?]+', prompt)
+        
+        first_part = sentences[0] if sentences else prompt[:200]
+        
+        # Extract action verbs
+        action_words = re.findall(r'\b(create|write|analyze|explain|develop|design|implement|compare)\b', 
+                                   prompt.lower())
+        
+        if action_words:
+            actions = ', '.join(set(action_words[:5]))
+            return f"{first_part}. Main tasks: {actions}."
+        
+        return first_part + "..."
+    
+    def _extract_first_goal(self, prompt: str) -> str:
+        """Extract first clear goal from prompt"""
+        sentences = re.split(r'[.!?]+', prompt)
+        return sentences[0] if sentences else prompt[:200]
+    
+    def _create_structured_long_prompt(self, prompt: str) -> str:
+        """Add structure to long prompt"""
+        chunks = self.chunk_long_prompt(prompt, 1000)
+        
+        structured = "# Structured Request\n\n"
+        for i, chunk in enumerate(chunks[:3], 1):  # Limit to 3 sections
+            structured += f"## Section {i}\n{chunk}\n\n"
+        
+        if len(chunks) > 3:
+            structured += f"[Note: {len(chunks) - 3} additional sections - consider splitting]"
+        
+        return structured
+    
+    def _add_structure(self, prompt: str, industry: str, analysis: dict) -> str:
+        """Add clear structure to prompt"""
+        
+        # Industry-specific templates
+        templates = {
+            'code': "Task: {prompt}\n\nRequirements:\n- Programming language: [Specify]\n- Expected output format: [Describe]\n- Edge cases to consider: [List]",
+            'data': "Analysis Request: {prompt}\n\nData Context:\n- Data source: [Specify]\n- Analysis type: [Descriptive/Predictive/Prescriptive]\n- Desired output: [Charts/Tables/Summary]",
+            'creative': "Creative Brief: {prompt}\n\nStyle Guide:\n- Tone: [Professional/Casual/etc]\n- Target audience: [Specify]\n- Length: [Word count]",
+            'business': "Business Request: {prompt}\n\nContext:\n- Objective: [Primary goal]\n- Audience: [Stakeholders]\n- Format: [Presentation/Report/Email]",
+            'general': "{prompt}\n\nPlease provide:\n- Clear explanation\n- Structured response\n- Specific examples"
+        }
+        
+        template = templates.get(industry, templates['general'])
+        
+        if len(prompt) < 100:  # Short prompts need more structure
+            return template.format(prompt=prompt)
+        
+        return f"{prompt}\n\nFormat your response with clear sections and examples."
+    
+    def _add_context(self, prompt: str, industry: str, analysis: dict) -> str:
+        """Add context and constraints"""
+        
+        context_additions = {
+            'code': "\n\nAdditional Context:\n- Code should be production-ready\n- Include error handling\n- Add inline comments for clarity",
+            'data': "\n\nConstraints:\n- Focus on actionable insights\n- Include data visualizations if applicable\n- Cite sources for statistics",
+            'creative': "\n\nGuidelines:\n- Maintain consistent voice throughout\n- Use vivid, specific language\n- Target length: 300-500 words",
+            'business': "\n\nDeliverables:\n- Executive summary at the top\n- Data-driven recommendations\n- Clear action items",
+            'general': "\n\nPlease ensure:\n- Step-by-step explanation\n- Real-world examples\n- Clear, actionable takeaways"
+        }
+        
+        addition = context_additions.get(industry, context_additions['general'])
+        return prompt + addition
+    
+    def _optimize_for_ai(self, prompt: str, industry: str, analysis: dict) -> str:
+        """Optimize prompt for best AI results"""
+        
+        # Remove vague language
+        optimized = re.sub(r'\b(thing|stuff|something)\b', 'specific item', prompt, flags=re.IGNORECASE)
+        optimized = re.sub(r'\b(good|bad|nice)\b', 'appropriate', optimized, flags=re.IGNORECASE)
+        
+        # Add AI-friendly instructions
+        ai_instructions = {
+            'code': "\n\n[AI Instructions: Provide clean, well-commented code with explanations. Include usage examples and potential gotchas.]",
+            'data': "\n\n[AI Instructions: Present data insights in a structured format. Use bullet points for key findings. Include visualization suggestions.]",
+            'creative': "\n\n[AI Instructions: Use engaging language and narrative structure. Vary sentence length for rhythm. Include sensory details.]",
+            'business': "\n\n[AI Instructions: Lead with conclusions. Support with data. End with specific recommendations. Use professional tone.]",
+            'general': "\n\n[AI Instructions: Structure response clearly. Use examples. Be specific and actionable.]"
+        }
+        
+        instruction = ai_instructions.get(industry, ai_instructions['general'])
+        
+        return optimized + instruction
+    
+    def _get_improvements(self, new_prompt: str, original: str, strategy: str) -> List[str]:
+        """List specific improvements made"""
+        
+        improvements = {
+            'structure': ['Added clear structure', 'Organized into sections', 'Improved readability'],
+            'context': ['Added relevant context', 'Specified constraints', 'Clarified expectations'],
+            'ai_optimized': ['Removed vague language', 'Added AI-friendly instructions', 'Enhanced specificity']
+        }
+        
+        return improvements.get(strategy, ['Enhanced clarity', 'Improved specificity'])
 
-router = APIRouter(prefix="/prompt-variants", tags=["prompts"])
 
-# Initialize generator
-generator = RuleBasedGenerator()
+# Global analyzer instance
+analyzer = PromptAnalyzer()
 
 
 @router.post("/")
-async def generate_variants(
-    original_prompt: str,
-    context: str = None,
-    api_key: str = Depends(verify_api_key)
+async def get_prompt_variants(
+    original_prompt: str = Query(..., description="The original prompt to improve"),
+    context: str = Query("general", description="Context: general, code, data, creative, business")
 ):
     """
-    Generate 3 improved variants of a prompt
-    
-    This endpoint analyzes the original prompt and generates three
-    improved versions with better clarity, structure, and specificity.
-    
-    Args:
-        original_prompt: User's original prompt text
-        context: Optional AI tool context (chatgpt, claude, etc)
-        api_key: Validated API key
-        
-    Returns:
-        Dictionary with variants array and metadata
-        
-    Example:
-        POST /prompt-variants/?original_prompt=make this better&context=chatgpt
-        
-        Response:
-        {
-            "variants": [
-                {
-                    "text": "Improve the following...",
-                    "improvements": ["Added clarity"],
-                    "score": 85
-                },
-                ...
-            ],
-            "original_prompt": "make this better",
-            "generation_method": "rule_based"
-        }
-    """
-    # Validate prompt
-    if not original_prompt or not original_prompt.strip():
-        raise HTTPException(
-            status_code=400,
-            detail="Prompt cannot be empty"
-        )
+    Generate improved prompt variants
+    
+    **Enterprise Features:**
+    - Supports prompts up to 10,000 characters
+    - Industry-specific optimizations
+    - Smart chunking for long content
+    - Quality scoring and analysis
+    - Multiple improvement strategies
+    
+    **Supported Industries:**
+    - code: Programming and technical tasks
+    - data: Data analysis and visualization
+    - creative: Writing and content creation
+    - business: Reports and presentations
+    - general: General purpose
     
-    original_prompt = original_prompt.strip()
+    **Example:**
+    ```
+    POST /prompt-variants/?original_prompt=write%20code&context=code
+    ```
+    """
     
-    if len(original_prompt) < 3:
+    # Validate length
+    if len(original_prompt) > 10000:
         raise HTTPException(
-            status_code=400,
-            detail="Prompt is too short (minimum 3 characters)"
+            status_code=400, 
+            detail="Prompt exceeds maximum length (10,000 characters). Consider breaking into multiple prompts."
         )
     
-    if len(original_prompt) > 2000:
+    if len(original_prompt.strip()) < 3:
         raise HTTPException(
             status_code=400,
-            detail="Prompt is too long (maximum 2000 characters)"
+            detail="Prompt is too short (minimum 3 characters)"
         )
     
-    # Check cache first
-    cached_variants = prompt_cache.get(original_prompt)
-    if cached_variants:
-        return {
-            "variants": cached_variants,
-            "original_prompt": original_prompt,
-            "generation_method": "rule_based (cached)"
-        }
-    
-    # Generate variants
     try:
-        variants = generator.generate_variants(
-            original_prompt=original_prompt,
-            context=context
-        )
+        # Generate variants
+        variants = analyzer.generate_variants(original_prompt, context)
         
-        # Cache the results
-        prompt_cache.set(original_prompt, variants)
+        # Get quality analysis
+        quality = analyzer.analyze_quality(original_prompt)
         
         return {
-            "variants": variants,
-            "original_prompt": original_prompt,
-            "generation_method": "rule_based"
+            'original_prompt': original_prompt,
+            'context': context,
+            'original_quality': quality,
+            'variants': variants,
+            'metadata': {
+                'generated_at': datetime.utcnow().isoformat(),
+                'industry_detected': analyzer.detect_industry(original_prompt),
+                'is_long_prompt': len(original_prompt) > 2000,
+                'word_count': quality['word_count'],
+                'char_count': quality['char_count']
+            }
         }
-        
+    
     except Exception as e:
         raise HTTPException(
             status_code=500,
-            detail=f"Failed to generate variants: {str(e)}"
-        )
-
-
-@router.post("/log")
-async def log_prompt_choice(
-    log_data: PromptLogCreate,
-    db: Session = Depends(get_db),
-    api_key: str = Depends(verify_api_key)
-):
-    """
-    Log which prompt variant the user chose
-    
-    Called by extension after user selects a variant.
-    Used for analytics on adoption rates.
-    
-    Args:
-        log_data: Contains original prompt, chosen variant, and all variants
-        db: Database session
-        api_key: Validated API key
-        
-    Returns:
-        Created prompt log record
-    """
-    # Find or create user
-    user = db.query(User).filter(User.email == log_data.user_email).first()
-    if not user:
-        user = User(
-            email=log_data.user_email,
-            org_id=1,
-            role="employee"
-        )
-        db.add(user)
-        db.commit()
-        db.refresh(user)
-    
-    # Create prompt log
-    prompt_log = PromptLog(
-        user_id=user.id,
-        original_prompt=log_data.original_prompt,
-        chosen_variant=log_data.chosen_variant,
-        variants_json=[v.model_dump() for v in log_data.variants]
-    )
-    db.add(prompt_log)
-    db.commit()
-    db.refresh(prompt_log)
-    
-    return prompt_log
-
-
-@router.get("/cache-stats")
-async def get_cache_stats(api_key: str = Depends(verify_api_key)):
-    """
-    Get cache statistics
-    
-    Returns information about the prompt cache
-    """
-    return {
-        "enabled": True,
-        "size": prompt_cache.size(),
-        "type": "in-memory"
-    }
+            detail=f"Error generating variants: {str(e)}"
+        )
\ No newline at end of file
diff --git a/backend/app/api/routes/usage.py b/backend/app/api/routes/usage.py
index b0bb370..b929f96 100644
--- a/backend/app/api/routes/usage.py
+++ b/backend/app/api/routes/usage.py
@@ -1,74 +1,43 @@
 """
-Usage logs API endpoints.
-Handles logging AI tool usage events.
+Usage logs API endpoints with RBAC support.
+Handles logging AI tool usage events with role-based data access.
 """
-from fastapi import APIRouter, Depends, HTTPException, Query
+from fastapi import APIRouter, Depends, HTTPException, Query, status
 from sqlalchemy.orm import Session
 from typing import List, Optional
 from datetime import datetime, timedelta
 import hashlib
 
-from ...models.database import UsageLog, User
+from ...models.database import UsageLog, User, UserRole, get_db
 from ...models.schemas import UsageLogCreate, UsageLogResponse
-from ...core.security import verify_api_key
-from ...models.database import Base
-from sqlalchemy import create_engine
-from sqlalchemy.orm import sessionmaker
-from ...core.config import settings
+from ...core.security import get_current_user
 
 router = APIRouter(prefix="/usage-logs", tags=["usage"])
 
-# Database session dependency
-engine = create_engine(settings.DATABASE_URL)
-SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
-
-
-def get_db():
-    """Dependency to get database session"""
-    db = SessionLocal()
-    try:
-        yield db
-    finally:
-        db.close()
-
 
 @router.post("/", response_model=UsageLogResponse, status_code=201)
 async def create_usage_log(
     log_data: UsageLogCreate,
     db: Session = Depends(get_db),
-    api_key: str = Depends(verify_api_key)
+    current_user: User = Depends(get_current_user)
 ):
     """
     Log an AI tool usage event.
-    
+
     Called by browser extension whenever user interacts with AI tool.
-    Creates user if not exists (self-registration).
-    
+    User is already created by get_current_user if first login.
+
     Args:
         log_data: Usage log details from extension
         db: Database session
-        api_key: Validated API key
-        
+        current_user: Current authenticated user from Auth0 JWT
+
     Returns:
         Created usage log record
     """
-    # Find or create user
-    user = db.query(User).filter(User.email == log_data.user_email).first()
-    if not user:
-        # Auto-register user (POC simplification)
-        # In production: Would require admin approval or SSO integration
-        user = User(
-            email=log_data.user_email,
-            org_id=1,  # POC: All users in org 1
-            role="employee"
-        )
-        db.add(user)
-        db.commit()
-        db.refresh(user)
-    
-    # Create usage log
+    # Create usage log for current user
     usage_log = UsageLog(
-        user_id=user.id,
+        user_id=current_user.id,
         tool=log_data.tool,
         prompt_hash=log_data.prompt_hash,
         risk_level=log_data.risk_level
@@ -76,7 +45,7 @@ async def create_usage_log(
     db.add(usage_log)
     db.commit()
     db.refresh(usage_log)
-    
+
     return usage_log
 
 
@@ -86,44 +55,154 @@ async def get_usage_logs(
     tool: Optional[str] = Query(None, description="Filter by AI tool"),
     days: int = Query(7, description="Number of days to look back"),
     db: Session = Depends(get_db),
-    api_key: str = Depends(verify_api_key)
+    current_user: User = Depends(get_current_user)
 ):
     """
-    Retrieve usage logs with optional filters.
-    
-    Used by dashboard to display usage history.
-    
+    Retrieve usage logs with role-based filtering.
+
+    Permissions:
+    - Security Team: Can view all users' logs
+    - Team Lead: Can view own team's logs
+    - Employee: Can view only their own logs
+
     Args:
-        user_email: Optional filter by user
+        user_email: Optional filter by user (ignored for employees)
         tool: Optional filter by AI tool
         days: How many days of history to return
         db: Database session
-        api_key: Validated API key
-        
+        current_user: Current authenticated user
+
     Returns:
-        List of usage logs matching filters
+        List of usage logs matching filters and permissions
     """
     # Start with base query
     query = db.query(UsageLog)
-    
+
     # Apply time filter
     start_date = datetime.utcnow() - timedelta(days=days)
     query = query.filter(UsageLog.timestamp >= start_date)
+
+    # Apply role-based filtering
+    if current_user.role == UserRole.SECURITY_TEAM:
+        # Security team sees all users in organization
+        user_ids = db.query(User.id).filter(
+            User.org_id == current_user.org_id
+        ).all()
+        accessible_ids = [uid[0] for uid in user_ids]
+        query = query.filter(UsageLog.user_id.in_(accessible_ids))
+        
+        # If specific user email requested, filter to that user
+        if user_email:
+            target_user = db.query(User).filter(User.email == user_email).first()
+            if target_user:
+                query = query.filter(UsageLog.user_id == target_user.id)
     
-    # Apply user filter if provided
-    if user_email:
-        user = db.query(User).filter(User.email == user_email).first()
-        if user:
-            query = query.filter(UsageLog.user_id == user.id)
+    elif current_user.role == UserRole.TEAM_LEAD:
+        # Team leads see their team members
+        if current_user.team_id:
+            team_user_ids = db.query(User.id).filter(
+                User.team_id == current_user.team_id
+            ).all()
+            accessible_ids = [uid[0] for uid in team_user_ids]
+            query = query.filter(UsageLog.user_id.in_(accessible_ids))
+        else:
+            # If no team, see only own logs
+            query = query.filter(UsageLog.user_id == current_user.id)
     
+    else:  # Employee
+        # Employees see only their own logs
+        query = query.filter(UsageLog.user_id == current_user.id)
+
     # Apply tool filter if provided
     if tool:
         query = query.filter(UsageLog.tool == tool)
-    
+
     # Order by most recent first
     query = query.order_by(UsageLog.timestamp.desc())
-    
-    # Limit to 1000 records for POC (prevent huge responses)
+
+    # Limit to 1000 records
     logs = query.limit(1000).all()
-    
+
     return logs
+
+
+@router.get("/stats")
+async def get_usage_stats(
+    days: int = Query(7, description="Number of days to analyze"),
+    db: Session = Depends(get_db),
+    current_user: User = Depends(get_current_user)
+):
+    """
+    Get usage statistics based on user permissions.
+    
+    Returns aggregated stats for logs the user can access.
+    
+    Args:
+        days: Number of days to analyze
+        db: Database session
+        current_user: Current authenticated user
+    
+    Returns:
+        Usage statistics (total logs, by tool, by risk level, etc.)
+    """
+    from sqlalchemy import func
+    
+    # Get accessible user IDs based on role
+    if current_user.role == UserRole.SECURITY_TEAM:
+        accessible_ids = db.query(User.id).filter(
+            User.org_id == current_user.org_id
+        ).all()
+        accessible_ids = [uid[0] for uid in accessible_ids]
+    elif current_user.role == UserRole.TEAM_LEAD and current_user.team_id:
+        accessible_ids = db.query(User.id).filter(
+            User.team_id == current_user.team_id
+        ).all()
+        accessible_ids = [uid[0] for uid in accessible_ids]
+    else:
+        accessible_ids = [current_user.id]
+    
+    # Calculate date range
+    start_date = datetime.utcnow() - timedelta(days=days)
+    
+    # Base query with filters
+    base_query = db.query(UsageLog).filter(
+        UsageLog.user_id.in_(accessible_ids),
+        UsageLog.timestamp >= start_date
+    )
+    
+    # Total logs
+    total_logs = base_query.count()
+    
+    # Logs by tool
+    logs_by_tool = db.query(
+        UsageLog.tool,
+        func.count(UsageLog.id).label('count')
+    ).filter(
+        UsageLog.user_id.in_(accessible_ids),
+        UsageLog.timestamp >= start_date
+    ).group_by(UsageLog.tool).all()
+    
+    # Logs by risk level
+    logs_by_risk = db.query(
+        UsageLog.risk_level,
+        func.count(UsageLog.id).label('count')
+    ).filter(
+        UsageLog.user_id.in_(accessible_ids),
+        UsageLog.timestamp >= start_date
+    ).group_by(UsageLog.risk_level).all()
+    
+    # Unique users
+    unique_users = db.query(func.count(func.distinct(UsageLog.user_id))).filter(
+        UsageLog.user_id.in_(accessible_ids),
+        UsageLog.timestamp >= start_date
+    ).scalar()
+    
+    return {
+        "total_logs": total_logs,
+        "unique_users": unique_users,
+        "logs_by_tool": {tool: count for tool, count in logs_by_tool},
+        "logs_by_risk": {risk: count for risk, count in logs_by_risk},
+        "accessible_user_count": len(accessible_ids),
+        "user_role": current_user.role.value,
+        "days_analyzed": days
+    }
\ No newline at end of file
diff --git a/backend/app/core/config.py b/backend/app/core/config.py
index bdd6841..3a5295f 100644
--- a/backend/app/core/config.py
+++ b/backend/app/core/config.py
@@ -14,13 +14,19 @@ class Settings(BaseSettings):
     # Database connection string
     # Format: postgresql://username:password@host:port/database_name
     DATABASE_URL: str
-    
+
+    # Auth0 Configuration
+    AUTH0_DOMAIN: str = "dev-y75lecimhanaeqy7.us.auth0.com"
+    AUTH0_API_AUDIENCE: str = "https://blah-subsequent-personal-synthetic.trycloudflare.com"
+
     # Secret key for API key validation (change in production)
-    API_KEY_SECRET: str
-    
+    API_KEY_SECRET: str = "your-secret-key-change-this-in-production"
+
     # CORS allowed origins (comma-separated list)
-    ALLOWED_ORIGINS: str = "http://localhost:3000"
-    
+    # Update this in backend/.env when ngrok URLs change
+    CORS_ORIGINS: str = "https://surrey-tide-neutral-presence.trycloudflare.com,http://localhost:5173,http://localhost:3000"
+    ALLOWED_ORIGINS: str = "https://surrey-tide-neutral-presence.trycloudflare.com,http://localhost:5173,http://localhost:3000"
+
     # Server configuration
     HOST: str = "0.0.0.0"
     PORT: int = 8000
@@ -32,6 +38,10 @@ class Settings(BaseSettings):
         """Convert comma-separated origins string to list"""
         return [origin.strip() for origin in self.ALLOWED_ORIGINS.split(",")]
 
+    def get_cors_origins(self) -> List[str]:
+        """Convert comma-separated CORS origins string to list"""
+        return [origin.strip() for origin in self.CORS_ORIGINS.split(",")]
+
 
 # Global settings instance
 settings = Settings()
diff --git a/backend/app/core/security.py b/backend/app/core/security.py
index 5e64273..0c7f22e 100644
--- a/backend/app/core/security.py
+++ b/backend/app/core/security.py
@@ -1,42 +1,202 @@
-"""
-Security utilities for API key validation and authentication.
-"""
-from fastapi import HTTPException, Security, status
-from fastapi.security import APIKeyHeader
+from fastapi import Depends, HTTPException, status
+from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
+from jose import jwt, JWTError
+import requests
+from functools import wraps
+from typing import Callable, Optional
+import os
+from datetime import datetime
 from .config import settings
+from sqlalchemy.orm import Session
+from ..models.database import get_db
 
-# API Key header scheme - expects "X-API-Key" header in requests
-api_key_header = APIKeyHeader(name="X-API-Key", auto_error=False)
+security = HTTPBearer()
 
+# Auth0 configuration from environment variables or settings
+AUTH0_DOMAIN = os.getenv("AUTH0_DOMAIN") or settings.AUTH0_DOMAIN
+AUTH0_API_AUDIENCE = os.getenv("AUTH0_API_AUDIENCE") or settings.AUTH0_API_AUDIENCE
+ALGORITHMS = ["RS256"]
 
-async def verify_api_key(api_key: str = Security(api_key_header)) -> str:
+# Cache the JWKS
+jwks_cache = None
+jwks_cache_time = None
+JWKS_CACHE_TTL = 3600  # Cache for 1 hour
+
+def get_jwks():
+    """Get JWKS with caching"""
+    global jwks_cache, jwks_cache_time
+    now = datetime.now().timestamp()
+
+    if jwks_cache is None or (jwks_cache_time and now - jwks_cache_time > JWKS_CACHE_TTL):
+        try:
+            jwks_url = f"https://{AUTH0_DOMAIN}/.well-known/jwks.json"
+            response = requests.get(jwks_url, timeout=10)
+            response.raise_for_status()
+            jwks_cache = response.json()
+            jwks_cache_time = now  
+            
+        except requests.RequestException as e:
+            raise HTTPException(
+                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
+                detail=f"Unable to fetch Auth0 JWKS: {str(e)}"
+            )
+    return jwks_cache
+
+async def verify_token(
+    credentials: HTTPAuthorizationCredentials = Depends(security)
+) -> dict:
     """
-    Validate API key from request header.
-    
-    For POC: Uses a simple secret key comparison.
-    In production: Would validate against database of org-specific keys.
-    
+    Verify Auth0 JWT token and return payload.
+
     Args:
-        api_key: The API key from request header
-        
+        credentials: Bearer token from Authorization header
+
     Returns:
-        The validated API key
-        
+        JWT payload containing user information
+
     Raises:
-        HTTPException: If API key is missing or invalid
+        HTTPException: If token is invalid or expired
     """
-    if not api_key:
+    token = credentials.credentials
+
+    try:
+        # Get signing key
+        jwks = get_jwks()
+        unverified_header = jwt.get_unverified_header(token)
+        rsa_key = {}
+
+        # Find the key with matching kid
+        for key in jwks.get("keys", []):
+            if key.get("kid") == unverified_header.get("kid"):
+                rsa_key = {
+                    "kty": key.get("kty"),
+                    "kid": key.get("kid"),
+                    "use": key.get("use"),
+                    "n": key.get("n"),
+                    "e": key.get("e")
+                }
+                break
+
+        if not rsa_key:
+            raise HTTPException(
+                status_code=status.HTTP_401_UNAUTHORIZED,
+                detail="Unable to find appropriate signing key"
+            )
+
+        # Verify token signature and claims
+        payload = jwt.decode(
+            token,
+            rsa_key,
+            algorithms=ALGORITHMS,
+            audience=AUTH0_API_AUDIENCE,
+            issuer=f"https://{AUTH0_DOMAIN}/"
+        )
+        return payload
+
+    except JWTError as e:
         raise HTTPException(
             status_code=status.HTTP_401_UNAUTHORIZED,
-            detail="Missing API key. Include 'X-API-Key' header."
+            detail=f"Invalid or expired token: {str(e)}"
         )
-    
-    # POC: Simple validation against secret key
-    # Production: Query database for org_id associated with this key
-    if api_key != settings.API_KEY_SECRET:
+    except Exception as e:
         raise HTTPException(
-            status_code=status.HTTP_403_FORBIDDEN,
-            detail="Invalid API key"
+            status_code=status.HTTP_401_UNAUTHORIZED,
+            detail=f"Token verification failed: {str(e)}"
         )
+
+async def get_current_user(
+    payload: dict = Depends(verify_token),
+    db: Session = Depends(get_db)
+):
+    """
+    Get or create current user from JWT payload.
+    Auto-creates user in database if doesn't exist (first login).
+
+    Args:
+        payload: Verified JWT payload
+        db: Database session
+
+    Returns:
+        User object from database with role and permissions
+    """
+    from ..models.database import User, Organization, UserRole
+    
+    # Get email from token - try multiple fields
+    email = payload.get("email") or payload.get("https://your-domain.com/email")
+    
+    # If no email, use Auth0 sub as identifier (convert to email-like format)
+    if not email:
+        sub = payload.get("sub")
+        if sub:
+            # Convert Auth0 ID to valid email format: auth0|xxx -> auth0-xxx@auth0.local
+            email = sub.replace("|", "-") + "@auth0.local"
+        else:
+            raise HTTPException(
+                status_code=status.HTTP_401_UNAUTHORIZED,
+                detail="Token does not contain user email or subject"
+            )
+
+    # Find existing user
+    user = db.query(User).filter(User.email == email).first()
+    
+    if not user:
+        # Auto-create user on first login
+        name = payload.get("name") or payload.get("nickname") or email.split("@")[0]
+        picture = payload.get("picture", "")
+        
+        # Determine organization from email domain
+        email_domain = email.split('@')[-1] if '@' in email else None
+        org = None
+        
+        # Only try to match org if it's a real email domain (not auth0.local)
+        if email_domain and email_domain != "auth0.local":
+            org = db.query(Organization).filter(
+                Organization.domain == email_domain
+            ).first()
+        
+        # Default to SJSU (id=1) if no org found
+        org_id = org.id if org else 1
+        
+        # Create new user with employee role by default
+        user = User(
+            email=email,
+            name=name,
+            picture=picture,
+            role=UserRole.EMPLOYEE,  # Default role
+            org_id=org_id
+        )
+        db.add(user)
+        db.commit()
+        db.refresh(user)
+    
+    return user
+
+def require_role(*allowed_roles):
+    """
+    Dependency to require specific roles.
+    
+    Usage:
+        @router.get("/admin-only")
+        def admin_endpoint(current_user = Depends(require_role(UserRole.SECURITY_TEAM))):
+            ...
+    """
+    from ..models.database import UserRole
+    
+    def role_checker(current_user = Depends(get_current_user)):
+        # Convert to role values
+        allowed_role_values = [
+            role if hasattr(role, 'value') else role 
+            for role in allowed_roles
+        ]
+        
+        user_role = current_user.role if hasattr(current_user.role, 'value') else current_user.role
+        
+        if user_role not in allowed_role_values:
+            raise HTTPException(
+                status_code=status.HTTP_403_FORBIDDEN,
+                detail=f"Insufficient permissions. Required roles: {allowed_role_values}"
+            )
+        
+        return current_user
     
-    return api_key
+    return role_checker
\ No newline at end of file
diff --git a/backend/app/main.py b/backend/app/main.py
index fbe7675..276f66f 100644
--- a/backend/app/main.py
+++ b/backend/app/main.py
@@ -2,8 +2,10 @@ from fastapi import FastAPI
 from fastapi.middleware.cors import CORSMiddleware
 from .core.config import settings
 from .models.database import Base, engine
-from .api.routes import usage, policies, analytics, prompts
-from .api.routes import prompt_history
+from .api.routes import usage, policies, analytics, prompts, prompt_history, prompt_logs, users
+import os
+from fastapi import Depends
+from .core.security import get_current_user
 
 # Create database tables
 Base.metadata.create_all(bind=engine)
@@ -14,15 +16,32 @@ app = FastAPI(
     description="""
 # AI Governance API
 
-Enterprise AI usage monitoring and governance backend.
+Enterprise AI usage monitoring and governance backend using Auth0 for authentication.
 
 ## Features
 
-*  **Authentication**: API key-based authentication
-*  **Usage Tracking**: Log all AI tool interactions  
+*  **Authentication**: Auth0 JWT token-based authentication
+*  **User Management**: User registration and profile management
+*  **Usage Tracking**: Log all AI tool interactions
 *  **PII Detection**: Compliance alerts for sensitive data
 *  **Prompt Improvements**: AI-powered prompt variant generation
 *  **Policies**: Organization-level governance rules
+*  **RBAC**: Role-based access control (Employee, Manager, Admin)
+
+## Authentication
+
+All endpoints (except `/health` and `/`) require an Auth0 JWT token in the `Authorization` header.
+
+Example:
+```bash
+curl -H "Authorization: Bearer YOUR_AUTH0_JWT_TOKEN" https://blah-subsequent-personal-synthetic.trycloudflare.com/users/me
+```
+
+## Getting Started
+
+1. Authenticate with Auth0 to get a JWT token
+2. Register your user: `POST /users/register`
+3. Access protected endpoints with your JWT token
 
 ## Database Schema
 
@@ -31,90 +50,41 @@ Enterprise AI usage monitoring and governance backend.
 CREATE TABLE users (
     id SERIAL PRIMARY KEY,
     email VARCHAR(255) UNIQUE NOT NULL,
+    name VARCHAR(255),
+    picture VARCHAR(500),
     org_id INTEGER NOT NULL,
     role VARCHAR(50) DEFAULT 'employee',
     created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
 );
 ```
 
-### Usage Logs Table  
-```sql
-CREATE TABLE usage_logs (
-    id SERIAL PRIMARY KEY,
-    user_id INTEGER REFERENCES users(id),
-    tool VARCHAR(100) NOT NULL,
-    prompt_hash VARCHAR(64),
-    risk_level VARCHAR(10) DEFAULT 'low',
-    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
-);
-```
-
-### Prompt Logs Table
-```sql
-CREATE TABLE prompt_logs (
-    id SERIAL PRIMARY KEY,
-    user_id INTEGER REFERENCES users(id),
-    original_prompt TEXT,
-    chosen_variant TEXT,
-    variants_json JSON,
-    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
-);
-```
-
-### Policies Table
-```sql
-CREATE TABLE policies (
-    id SERIAL PRIMARY KEY,
-    org_id INTEGER NOT NULL,
-    name VARCHAR(255) NOT NULL,
-    rules_json JSON NOT NULL,
-    active BOOLEAN DEFAULT TRUE,
-    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
-    updated_at TIMESTAMP WITH TIME ZONE
-);
-```
-
-### Alerts Table
-```sql
-CREATE TABLE alerts (
-    id SERIAL PRIMARY KEY,
-    user_id INTEGER REFERENCES users(id),
-    violation_type VARCHAR(100) NOT NULL,
-    details JSON,
-    resolved BOOLEAN DEFAULT FALSE,
-    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
-);
-```
-
-## Authentication
-
-All endpoints require an API key in the `X-API-Key` header.
-
-Example:
-```bash
-curl -H "X-API-Key: your-api-key-here" http://localhost:8000/health
-```
+See `/docs` for complete API documentation.
     """,
-    version="1.0.0",
+    version="2.0.0",
     docs_url="/docs",
     redoc_url="/redoc"
 )
 
-# Configure CORS
+# Configure CORS - restrict to specific origins
+# Origins are loaded from CORS_ORIGINS environment variable in backend/.env
+cors_origins = settings.get_cors_origins()
+
 app.add_middleware(
     CORSMiddleware,
-    allow_origins=["*"],
+    allow_origins=cors_origins or ["*"],
     allow_credentials=True,
-    allow_methods=["*"],
-    allow_headers=["*"],
+    allow_methods=["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
+    allow_headers=["Content-Type", "Authorization"],
 )
 
 # Include routers
-app.include_router(usage.router)
-app.include_router(policies.router)
-app.include_router(analytics.router)
-app.include_router(prompts.router)
-app.include_router(prompt_history.router)
+app.include_router(users.router, dependencies=[Depends(get_current_user)])
+app.include_router(usage.router, dependencies=[Depends(get_current_user)])
+app.include_router(policies.router, dependencies=[Depends(get_current_user)])
+app.include_router(analytics.router, dependencies=[Depends(get_current_user)])
+app.include_router(prompts.router, dependencies=[Depends(get_current_user)])
+app.include_router(prompt_history.router, dependencies=[Depends(get_current_user)])
+app.include_router(prompt_logs.router, dependencies=[Depends(get_current_user)])
 
 @app.get("/", tags=["Health"])
 async def root():
@@ -155,4 +125,14 @@ async def health_check():
         db.execute(text("SELECT 1"))
         return {"status": "healthy", "database": "connected"}
     except Exception as e:
-        return {"status": "unhealthy", "error": str(e)}
\ No newline at end of file
+        return {"status": "unhealthy", "error": str(e)}
+
+"""
+fetch('https://blah-subsequent-personal-synthetic.trycloudflare.com/test')
+  .then(r => r.json())
+  .then(data => console.log(data))
+  .catch(err => console.error(err));
+""" 
+@app.get("/test", tags=["Test"])
+async def test():
+    return {"message": "Backend connected", "timestamp": "now"}
\ No newline at end of file
diff --git a/backend/app/models/database.py b/backend/app/models/database.py
index 8fb3047..83388bc 100644
--- a/backend/app/models/database.py
+++ b/backend/app/models/database.py
@@ -1,140 +1,229 @@
-from sqlalchemy import Column, Integer, String, Text, DateTime, Boolean, JSON, ForeignKey, Enum, create_engine, Float
+"""
+Database models for AI Governance Platform
+"""
+from sqlalchemy import Column, Integer, String, Boolean, DateTime, Float, Text, ForeignKey, Enum as SQLEnum, JSON
+from sqlalchemy.orm import relationship, declarative_base
 from sqlalchemy.ext.declarative import declarative_base
-from sqlalchemy.orm import sessionmaker, relationship
-from sqlalchemy.sql import func
 from datetime import datetime
 import enum
 
 Base = declarative_base()
 
 
-class RiskLevel(str, enum.Enum):
-    """Enum for risk levels in usage logs"""
-    LOW = "low"
-    MEDIUM = "medium"
-    HIGH = "high"
+# ============================================
+# ENUMS
+# ============================================
+
+class UserRole(str, enum.Enum):
+    """User roles for RBAC"""
+    SECURITY_TEAM = "security_team"
+    TEAM_LEAD = "team_lead"
+    EMPLOYEE = "employee"
+
+
+# ============================================
+# MODELS
+# ============================================
+
+class Organization(Base):
+    """Organization model"""
+    __tablename__ = "organizations"
+    
+    id = Column(Integer, primary_key=True, index=True)
+    name = Column(String(100), nullable=False)
+    short_name = Column(String(20))
+    description = Column(Text)
+    domain = Column(String(100), index=True)
+    industry = Column(String(50))
+    address = Column(Text)
+    city = Column(String(100))
+    state = Column(String(50))
+    country = Column(String(50), default='USA')
+    created_at = Column(DateTime, default=datetime.utcnow)
+    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
+    is_active = Column(Boolean, default=True)
+    
+    # Relationships
+    users = relationship("User", back_populates="organization")
+    teams = relationship("Team", back_populates="organization")
+    policies = relationship("Policy", back_populates="organization")
+
+
+class Team(Base):
+    """Team model"""
+    __tablename__ = "teams"
+    
+    id = Column(Integer, primary_key=True, index=True)
+    name = Column(String(100), nullable=False)
+    description = Column(Text)
+    org_id = Column(Integer, ForeignKey("organizations.id"))
+    created_at = Column(DateTime, default=datetime.utcnow)
+    
+    # Relationships
+    organization = relationship("Organization", back_populates="teams")
+    members = relationship("User", back_populates="team", foreign_keys="User.team_id")
 
 
 class User(Base):
-    """Users table - stores employee information"""
+    """User model with RBAC support"""
     __tablename__ = "users"
     
     id = Column(Integer, primary_key=True, index=True)
     email = Column(String(255), unique=True, nullable=False, index=True)
-    org_id = Column(Integer, nullable=False, index=True)
-    role = Column(String(50), default="employee")
-    created_at = Column(DateTime(timezone=True), server_default=func.now())
+    name = Column(String(255))
+    picture = Column(String(500))
+    role = Column(String(50), default='employee')  # Will be converted to enum
+    team_id = Column(Integer, ForeignKey("teams.id"), nullable=True)
+    reports_to = Column(Integer, ForeignKey("users.id"), nullable=True)
+    org_id = Column(Integer, ForeignKey("organizations.id"))
+    created_at = Column(DateTime, default=datetime.utcnow)
+    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
     
     # Relationships
+    organization = relationship("Organization", back_populates="users")
+    team = relationship("Team", back_populates="members", foreign_keys=[team_id])
+    manager = relationship("User", remote_side=[id], backref="direct_reports")
+    
+    # Usage tracking
     usage_logs = relationship("UsageLog", back_populates="user")
     prompt_logs = relationship("PromptLog", back_populates="user")
     prompt_history = relationship("PromptHistory", back_populates="user")
-    alerts = relationship("Alert", back_populates="user")
+    
+    # Alerts and policies
+    alerts = relationship("Alert", back_populates="user", foreign_keys="Alert.user_id")
+    resolved_alerts = relationship("Alert", back_populates="resolver", foreign_keys="Alert.resolved_by")
+    created_policies = relationship("Policy", back_populates="creator")
 
 
 class UsageLog(Base):
-    """Usage logs - tracks every AI tool usage event"""
+    """Usage log model"""
     __tablename__ = "usage_logs"
     
     id = Column(Integer, primary_key=True, index=True)
-    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)
-    tool = Column(String(100), nullable=False)
+    user_id = Column(Integer, ForeignKey("users.id"))
+    tool = Column(String(50), nullable=False)
     prompt_hash = Column(String(64))
-    risk_level = Column(Enum(RiskLevel), default=RiskLevel.LOW)
-    timestamp = Column(DateTime(timezone=True), server_default=func.now(), index=True)
+    risk_level = Column(String(20), default='low')
+    timestamp = Column(DateTime, default=datetime.utcnow, index=True)
     
-    # Relationship
+    # Relationships
     user = relationship("User", back_populates="usage_logs")
 
 
 class PromptLog(Base):
-    """Prompt logs - stores original prompt and chosen variant"""
+    """Prompt log model"""
     __tablename__ = "prompt_logs"
     
     id = Column(Integer, primary_key=True, index=True)
-    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)
+    user_id = Column(Integer, ForeignKey("users.id"))
     original_prompt = Column(Text)
     chosen_variant = Column(Text)
     variants_json = Column(JSON)
-    variant_index = Column(Integer)  # Which variant was chosen (0-2, -1 = original)
-    improvement_score = Column(Float)  # Quality improvement score
-    timestamp = Column(DateTime(timezone=True), server_default=func.now())
+    variant_index = Column(Integer, default=-1)
+    improvement_score = Column(Float)
+    timestamp = Column(DateTime, default=datetime.utcnow, index=True)
     
-    # Relationship
+    # Relationships
     user = relationship("User", back_populates="prompt_logs")
 
 
 class PromptHistory(Base):
-    """
-    NEW: Complete prompt history with full context
-    Stores every prompt a user makes with metadata
-    """
+    """Prompt history model"""
     __tablename__ = "prompt_history"
     
     id = Column(Integer, primary_key=True, index=True)
-    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)
-    
-    # Prompt details
+    user_id = Column(Integer, ForeignKey("users.id"))
     original_prompt = Column(Text, nullable=False)
-    final_prompt = Column(Text, nullable=False)  # What was actually sent
-    tool = Column(String(100), nullable=False)  # chatgpt, claude, etc
-    
-    # Variant selection
-    variants_offered = Column(JSON)  # All 3 variants offered
-    variant_selected = Column(Integer)  # -1 = original, 0-2 = variant index
-    
-    # Quality metrics
-    original_score = Column(Float)  # Quality score of original
-    final_score = Column(Float)  # Quality score of final
-    improvement_delta = Column(Float)  # final_score - original_score
-    
-    # PII detection
+    final_prompt = Column(Text, nullable=False)
+    tool = Column(String(50), nullable=False)
+    variants_offered = Column(JSON)
+    variant_selected = Column(Integer, default=-1)
+    original_score = Column(Float)
+    final_score = Column(Float)
+    improvement_delta = Column(Float)
     had_pii = Column(Boolean, default=False)
-    pii_types = Column(JSON)  # Array of PII types detected
-    
-    # Context
-    session_id = Column(String(64))  # Browser session ID
-    conversation_context = Column(JSON)  # Previous messages if available
+    pii_types = Column(JSON)
+    session_id = Column(String(64), index=True)
+    timestamp = Column(DateTime, default=datetime.utcnow, index=True)
+    response_received = Column(DateTime)
+    response_length = Column(Integer)
     
-    # Metadata
-    timestamp = Column(DateTime(timezone=True), server_default=func.now(), index=True)
-    response_received = Column(Boolean, default=False)  # Did AI respond successfully
-    response_length = Column(Integer)  # Length of AI response
-    
-    # Relationship
+    # Relationships
     user = relationship("User", back_populates="prompt_history")
 
 
-class Policy(Base):
-    """Policies - organization-level rules for AI usage"""
-    __tablename__ = "policies"
+class Alert(Base):
+    """Alert model"""
+    __tablename__ = "alerts"
     
     id = Column(Integer, primary_key=True, index=True)
-    org_id = Column(Integer, nullable=False, index=True)
-    name = Column(String(255), nullable=False)
-    rules_json = Column(JSON, nullable=False)
-    active = Column(Boolean, default=True)
-    created_at = Column(DateTime(timezone=True), server_default=func.now())
-    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
+    user_id = Column(Integer, ForeignKey("users.id"))
+    violation_type = Column(String(50), nullable=False)
+    details = Column(JSON)
+    resolved = Column(Boolean, default=False, index=True)
+    timestamp = Column(DateTime, default=datetime.utcnow, index=True)
+    resolved_at = Column(DateTime)
+    resolved_by = Column(Integer, ForeignKey("users.id"), nullable=True)
+    
+    # Relationships
+    user = relationship("User", back_populates="alerts", foreign_keys=[user_id])
+    resolver = relationship("User", back_populates="resolved_alerts", foreign_keys=[resolved_by])
 
 
-class Alert(Base):
-    """Alerts - compliance violations and policy breaches"""
-    __tablename__ = "alerts"
+class Policy(Base):
+    """Policy model"""
+    __tablename__ = "policies"
     
     id = Column(Integer, primary_key=True, index=True)
-    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, index=True)
-    violation_type = Column(String(100), nullable=False)
-    details = Column(JSON)
-    resolved = Column(Boolean, default=False)
-    timestamp = Column(DateTime(timezone=True), server_default=func.now(), index=True)
+    org_id = Column(Integer, ForeignKey("organizations.id"))
+    name = Column(String(100), nullable=False)
+    description = Column(Text)
+    policy_type = Column(String(50))
+    rules = Column(JSON)
+    is_active = Column(Boolean, default=True, index=True)
+    created_at = Column(DateTime, default=datetime.utcnow)
+    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
+    created_by = Column(Integer, ForeignKey("users.id"))
     
-    # Relationship
-    user = relationship("User", back_populates="alerts")
+    # Relationships
+    organization = relationship("Organization", back_populates="policies")
+    creator = relationship("User", back_populates="created_policies")
+
 
+# ============================================
+# DATABASE SESSION MANAGEMENT
+# ============================================
 
-# Create database engine
-from ..core.config import settings
+from sqlalchemy import create_engine
+from sqlalchemy.orm import sessionmaker
+import os
 
-engine = create_engine(settings.DATABASE_URL)
+# Get database URL from environment
+DATABASE_URL = os.getenv("DATABASE_URL", "postgresql://aigovernance:password123@postgres:5432/aigovernance_db")
+
+# Create engine
+engine = create_engine(DATABASE_URL)
+
+# Create session factory
 SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
+
+
+def get_db():
+    """
+    Database session dependency
+    
+    Usage:
+        @router.get("/")
+        def endpoint(db: Session = Depends(get_db)):
+            ...
+    """
+    db = SessionLocal()
+    try:
+        yield db
+    finally:
+        db.close()
+
+
+def init_db():
+    """Initialize database - create all tables"""
+    Base.metadata.create_all(bind=engine)
diff --git a/backend/app/models/schemas.py b/backend/app/models/schemas.py
index 42782d1..40d9ec5 100644
--- a/backend/app/models/schemas.py
+++ b/backend/app/models/schemas.py
@@ -1,24 +1,125 @@
+"""
+Pydantic schemas for request/response validation
+"""
 from pydantic import BaseModel, EmailStr, Field
-from typing import Optional, List, Dict, Any
+from typing import Optional, List
 from datetime import datetime
 from enum import Enum
 
 
-class RiskLevel(str, Enum):
-    LOW = "low"
-    MEDIUM = "medium"
-    HIGH = "high"
+# ============================================
+# ENUMS
+# ============================================
 
+class UserRole(str, Enum):
+    """User role enum matching database"""
+    SECURITY_TEAM = "security_team"
+    TEAM_LEAD = "team_lead"
+    EMPLOYEE = "employee"
+
+
+# ============================================
+# USER SCHEMAS
+# ============================================
+
+class UserRegister(BaseModel):
+    """User registration schema"""
+    email: EmailStr
+    name: Optional[str] = None
+    picture: Optional[str] = None
+    org_id: int = 1
+    role: UserRole = Field(default=UserRole.EMPLOYEE)
+
+
+class UserResponse(BaseModel):
+    """User response schema"""
+    id: int
+    email: str  # Changed from EmailStr to allow Auth0 IDs
+    name: Optional[str]
+    picture: Optional[str]
+    role: str
+    team_id: Optional[int]
+    org_id: int
+    created_at: datetime
+    
+    class Config:
+        from_attributes = True
+
+
+class UserProfile(BaseModel):
+    """Extended user profile"""
+    id: int
+    email: str  # Changed from EmailStr to allow Auth0 IDs
+    name: Optional[str]
+    picture: Optional[str]
+    role: str
+    team_id: Optional[int]
+    org_id: int
+    created_at: datetime
+    
+    class Config:
+        from_attributes = True
+
+
+class UserUpdate(BaseModel):
+    """User update schema"""
+    name: Optional[str] = None
+    picture: Optional[str] = None
+    role: Optional[UserRole] = None
+    team_id: Optional[int] = None
+
+
+# ============================================
+# TEAM SCHEMAS
+# ============================================
+
+class TeamResponse(BaseModel):
+    """Team response schema"""
+    id: int
+    name: str
+    description: Optional[str]
+    org_id: int
+    created_at: datetime
+    
+    class Config:
+        from_attributes = True
+
+
+class TeamCreate(BaseModel):
+    """Team creation schema"""
+    name: str
+    description: Optional[str] = None
+    org_id: int = 1
+
+
+# ============================================
+# ORGANIZATION SCHEMAS
+# ============================================
+
+class OrganizationResponse(BaseModel):
+    """Organization response schema"""
+    id: int
+    name: str
+    short_name: Optional[str]
+    domain: Optional[str]
+    
+    class Config:
+        from_attributes = True
+
+
+# ============================================
+# USAGE LOG SCHEMAS
+# ============================================
 
-# Existing schemas...
 class UsageLogCreate(BaseModel):
-    user_email: EmailStr
+    """Create usage log"""
     tool: str
     prompt_hash: str
-    risk_level: RiskLevel = RiskLevel.LOW
+    risk_level: str = "low"
 
 
 class UsageLogResponse(BaseModel):
+    """Usage log response"""
     id: int
     user_id: int
     tool: str
@@ -30,25 +131,29 @@ class UsageLogResponse(BaseModel):
         from_attributes = True
 
 
-# Enhanced Prompt Log schemas
-class PromptVariant(BaseModel):
-    """Single prompt variant"""
+# ============================================
+# PROMPT LOG SCHEMAS
+# ============================================
+
+class VariantSchema(BaseModel):
+    """Prompt variant schema"""
     text: str
-    improvements: List[str]
     score: float
+    improvements: List[str] = []
 
 
 class PromptLogCreate(BaseModel):
     """Create prompt log"""
-    user_email: EmailStr
+    user_email: str
     original_prompt: str
     chosen_variant: str
-    variants: List[PromptVariant]
-    variant_index: int = Field(..., description="-1 for original, 0-2 for variant")
+    variants: List[VariantSchema]
+    variant_index: int = -1
     improvement_score: Optional[float] = None
 
 
 class PromptLogResponse(BaseModel):
+    """Prompt log response"""
     id: int
     user_id: int
     original_prompt: str
@@ -61,44 +166,23 @@ class PromptLogResponse(BaseModel):
         from_attributes = True
 
 
-# NEW: Prompt History schemas
+# ============================================
+# PROMPT HISTORY SCHEMAS
+# ============================================
+
 class PromptHistoryCreate(BaseModel):
     """Create prompt history entry"""
-    user_email: EmailStr = Field(..., example="john.doe@company.com")
-    
-    # Prompt details
-    original_prompt: str = Field(..., example="write code to sort array")
-    final_prompt: str = Field(..., example="Write Python code to sort an array...")
-    tool: str = Field(..., example="chatgpt")
-    
-    # Variant selection
-    variants_offered: Optional[List[Dict[str, Any]]] = Field(default=None)
-    variant_selected: int = Field(..., example=0, description="-1=original, 0-2=variant")
-    
-    # Quality metrics
-    original_score: Optional[float] = Field(default=None, example=45.0)
-    final_score: Optional[float] = Field(default=None, example=85.0)
-    
-    # PII detection
-    had_pii: bool = Field(default=False)
-    pii_types: Optional[List[str]] = Field(default=None, example=["email"])
-    
-    # Context
-    session_id: Optional[str] = Field(default=None)
-    
-    class Config:
-        json_schema_extra = {
-            "example": {
-                "user_email": "john.doe@company.com",
-                "original_prompt": "write code to sort array",
-                "final_prompt": "Write Python code to sort an array in ascending order...",
-                "tool": "chatgpt",
-                "variant_selected": 1,
-                "original_score": 45.0,
-                "final_score": 85.0,
-                "had_pii": False
-            }
-        }
+    user_email: str
+    original_prompt: str
+    final_prompt: str
+    tool: str
+    variants_offered: Optional[List[dict]] = None
+    variant_selected: int = -1
+    original_score: Optional[float] = None
+    final_score: Optional[float] = None
+    had_pii: bool = False
+    pii_types: Optional[List[str]] = None
+    session_id: Optional[str] = None
 
 
 class PromptHistoryResponse(BaseModel):
@@ -121,7 +205,7 @@ class PromptHistoryResponse(BaseModel):
 
 
 class PromptHistoryListResponse(BaseModel):
-    """List of prompt history with pagination"""
+    """Paginated prompt history list"""
     total: int
     page: int
     page_size: int
@@ -129,73 +213,79 @@ class PromptHistoryListResponse(BaseModel):
 
 
 class PromptHistoryStats(BaseModel):
-    """Statistics for prompt history"""
+    """Prompt history statistics"""
     total_prompts: int
     avg_improvement: float
     pii_incidents: int
     variant_adoption_rate: float
-    top_tools: List[Dict[str, Any]]
+    top_tools: List[dict]
     recent_prompts: List[PromptHistoryResponse]
 
 
-# Policy schemas
+# ============================================
+# ALERT SCHEMAS
+# ============================================
+
+class AlertCreate(BaseModel):
+    """Create alert"""
+    user_email: str
+    violation_type: str
+    details: dict
+
+
+class AlertResponse(BaseModel):
+    """Alert response"""
+    id: int
+    user_id: int
+    violation_type: str
+    details: dict
+    resolved: bool
+    timestamp: datetime
+    
+    class Config:
+        from_attributes = True
+
+
+# ============================================
+# POLICY SCHEMAS
+# ============================================
+
 class PolicyCreate(BaseModel):
+    """Create policy"""
     org_id: int
     name: str
-    rules_json: dict
+    description: Optional[str] = None
+    policy_type: str
+    rules: dict
+    is_active: bool = True
 
 
 class PolicyResponse(BaseModel):
+    """Policy response"""
     id: int
     org_id: int
     name: str
-    rules_json: dict
-    active: bool
+    description: Optional[str]
+    policy_type: str
+    rules: dict
+    is_active: bool
     created_at: datetime
     
     class Config:
         from_attributes = True
 
 
-# Alert schemas
-class AlertCreate(BaseModel):
-    user_email: EmailStr
-    violation_type: str
-    details: Optional[dict] = None
-
+# ============================================
+# ANALYTICS SCHEMAS
+# ============================================
 
-class AlertResponse(BaseModel):
-    id: int
-    user_id: int
-    violation_type: str
-    details: Optional[dict]
-    resolved: bool
-    timestamp: datetime
-    
-    class Config:
-        from_attributes = True
-
-# Analytics Schemas
 class UsageStats(BaseModel):
-    """Usage statistics response"""
+    """Usage statistics"""
     total_prompts: int
     unique_users: int
-    prompts_by_tool: Dict[str, int]
-    prompts_by_risk: Dict[str, int]
-    top_users: List[Dict[str, Any]]
-    
-    class Config:
-        json_schema_extra = {
-            "example": {
-                "total_prompts": 1247,
-                "unique_users": 45,
-                "prompts_by_tool": {"chatgpt": 850, "claude": 397},
-                "prompts_by_risk": {"low": 1200, "medium": 35, "high": 12},
-                "top_users": [
-                    {"email": "john@company.com", "count": 245}
-                ]
-            }
-        }
+    prompts_by_tool: dict
+    prompts_by_risk: dict
+    top_users: List[dict]
 
 
 class PromptImprovementStats(BaseModel):
@@ -205,22 +295,31 @@ class PromptImprovementStats(BaseModel):
     originals_kept: int
     adoption_rate: float
     avg_improvement: float
-    top_improvements: List[Dict[str, Any]]
-    
-    class Config:
-        json_schema_extra = {
-            "example": {
-                "total_suggestions": 543,
-                "variants_chosen": 412,
-                "originals_kept": 131,
-                "adoption_rate": 0.76,
-                "avg_improvement": 23.5,
-                "top_improvements": [
-                    {
-                        "original": "write code",
-                        "chosen": "Write Python code to...",
-                        "improvement": 45.0
-                    }
-                ]
-            }
-        }
\ No newline at end of file
+    top_improvements: List[dict]
+
+
+# ============================================
+# PROMPT VARIANT SCHEMAS
+# ============================================
+
+class PromptVariantRequest(BaseModel):
+    """Request for prompt variants"""
+    original_prompt: str
+    context: str = "general"
+
+
+class PromptVariantResponse(BaseModel):
+    """Prompt variant response"""
+    text: str
+    score: float
+    improvements: List[str]
+    strategy: str
+
+
+class PromptVariantsResponse(BaseModel):
+    """Multiple variants response"""
+    original_prompt: str
+    context: str
+    original_quality: dict
+    variants: List[PromptVariantResponse]
+    metadata: dict
\ No newline at end of file
diff --git a/backend/docker-compose.yml b/backend/docker-compose.yml
index dac1c2e..0d85dbc 100644
--- a/backend/docker-compose.yml
+++ b/backend/docker-compose.yml
@@ -18,23 +18,39 @@ services:
       interval: 10s
       timeout: 5s
       retries: 5
+    networks:
+      - aigovernance-network
 
   # FastAPI Backend
   backend:
     build: .
-    container_name: backend
+    container_name: aigovernance_backend
     environment:
+      # Use 'postgres' hostname inside Docker network
       DATABASE_URL: postgresql://aigovernance:password123@postgres:5432/aigovernance_db
       API_KEY_SECRET: dev-secret-key-change-in-production
-      ALLOWED_ORIGINS: http://localhost:3000,http://localhost:5173
+
+      # CORS Configuration - UPDATE when ngrok URLs change
+      CORS_ORIGINS: https://surrey-tide-neutral-presence.trycloudflare.com,http://localhost:5173,http://localhost:3000
+      ALLOWED_ORIGINS: https://surrey-tide-neutral-presence.trycloudflare.com,http://localhost:5173,http://localhost:3000
+
+      # Auth0 Configuration
+      AUTH0_DOMAIN: dev-y75lecimhanaeqy7.us.auth0.com
+      AUTH0_API_AUDIENCE: https://blah-subsequent-personal-synthetic.trycloudflare.com
     ports:
       - "8000:8000"
     depends_on:
       postgres:
         condition: service_healthy
     volumes:
-      - ./app:/app/app  # Mount code for hot reload
+      - ./app:/app/app
     command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload
+    networks:
+      - aigovernance-network
+
+networks:
+  aigovernance-network:
+    driver: bridge
 
 volumes:
-  postgres_data:
+  postgres_data:
\ No newline at end of file
diff --git a/backend/requirements.txt b/backend/requirements.txt
index a1f2c71..5e217d7 100644
--- a/backend/requirements.txt
+++ b/backend/requirements.txt
@@ -8,4 +8,6 @@ python-dotenv==1.0.0
 python-jose[cryptography]==3.3.0
 passlib[bcrypt]==1.7.4
 python-multipart==0.0.6
-email-validator==2.1.0
\ No newline at end of file
+email-validator==2.1.0
+python-jose[cryptography]==3.3.0
+requests==2.31.0
\ No newline at end of file
diff --git a/browser-extension/INSTALLATION.md b/browser-extension/INSTALLATION.md
index 5aca7ac..90a8f44 100644
--- a/browser-extension/INSTALLATION.md
+++ b/browser-extension/INSTALLATION.md
@@ -6,7 +6,7 @@ Edit `config.js`:
 
 ```javascript
 const CONFIG = {
-  API_URL: 'http://localhost:8000',
+  API_URL: 'https://blah-subsequent-personal-synthetic.trycloudflare.com',
   API_KEY: 'dev-secret-key-change-in-production',
   USER_EMAIL: 'test@company.com',  // Change this to your email
   ORG_ID: 1
@@ -66,7 +66,7 @@ Click extension icon to see:
 **Can't connect to backend:**
 - Ensure backend is running: `docker-compose up`
 - Check API_URL in config.js
-- Test: `curl http://localhost:8000/health`
+- Test: `curl https://blah-subsequent-personal-synthetic.trycloudflare.com/health`
 
 **Not intercepting prompts:**
 - Check browser console (F12) for errors
diff --git a/browser-extension/README.md b/browser-extension/README.md
index 62b2157..b21a113 100644
--- a/browser-extension/README.md
+++ b/browser-extension/README.md
@@ -30,8 +30,8 @@ Chrome extension that monitors AI tool usage, detects PII, and improves prompt q
 ## Prerequisites
 
 - Chrome or Edge browser
-- Backend running on `http://localhost:8000`
-- Dashboard running on `http://localhost:3000`
+- Backend running on `https://blah-subsequent-personal-synthetic.trycloudflare.com`
+- Dashboard running on `https://surrey-tide-neutral-presence.trycloudflare.com`
 
 ## Installation
 
@@ -59,7 +59,7 @@ Edit `config.js` before loading:
 
 ```javascript
 const CONFIG = {
-  API_URL: 'http://localhost:8000',  // Your backend URL
+  API_URL: 'https://blah-subsequent-personal-synthetic.trycloudflare.com',  // Your backend URL
   API_KEY: 'your-api-key',           // Match backend API_KEY_SECRET
   USER_EMAIL: 'user@company.com',    // User's email
   ORG_ID: 1
@@ -250,7 +250,7 @@ Edit `src/shared/variant-modal.js`, look for `_injectStyles()` method.
 
 ```bash
 # Test backend manually
-curl http://localhost:8000/health \
+curl https://blah-subsequent-personal-synthetic.trycloudflare.com/health \
   -H "X-API-Key: dev-secret-key-change-in-production"
 
 # Should return: {"status": "healthy"}
diff --git a/browser-extension/config.js b/browser-extension/config.js
index dba488f..71912e7 100644
--- a/browser-extension/config.js
+++ b/browser-extension/config.js
@@ -1,29 +1,25 @@
 /**
  * Configuration for the extension
- * Update these values based on your backend deployment
+ * Update these values based on your Auth0 and backend deployment
  */
 
 const CONFIG = {
   // Backend API URL
-  API_URL: 'http://localhost:8000',
-  
-  // API Key for authentication
-  API_KEY: 'dev-secret-key-change-in-production',
-  
-  // User email (in production, get from SSO or login)
-  // For POC, set this to test user email
-  USER_EMAIL: 'joshini.mn@gmail.com',
-  
-  // Organization ID
-  ORG_ID: 1,
-  
+  API_URL: 'https://blah-subsequent-personal-synthetic.trycloudflare.com',
+
+  // Auth0 Configuration
+  AUTH0_DOMAIN: 'dev-y75lecimhanaeqy7.us.auth0.com',
+  AUTH0_CLIENT_ID: 'b2Q5VZ2pv4Ve8YralLn1dUtAHeEnpJGl',
+  AUTH0_API_AUDIENCE: 'https://blah-subsequent-personal-synthetic.trycloudflare.com',
+
   // Feature flags
   FEATURES: {
     PII_DETECTION: true,
     PROMPT_VARIANTS: true,
-    USAGE_LOGGING: true
+    USAGE_LOGGING: true,
+    PROMPT_HISTORY: true
   },
-  
+
   // Supported AI tools
   AI_TOOLS: {
     'chat.openai.com': 'chatgpt',
diff --git a/browser-extension/src/background/service-worker.js b/browser-extension/src/background/service-worker.js
index c5dd2dc..11769f4 100644
--- a/browser-extension/src/background/service-worker.js
+++ b/browser-extension/src/background/service-worker.js
@@ -1,6 +1,6 @@
 /**
  * Background service worker
- * Handles extension lifecycle and badge updates
+ * Handles extension lifecycle, Auth0 authentication, and badge updates
  */
 
 console.log('[AI Governance] Background service worker loaded');
@@ -20,7 +20,7 @@ chrome.storage.local.get(['stats', 'lastStatsReset'], (result) => {
   resetDailyStats();
 });
 
-// Listen for messages from content scripts
+// Listen for messages from content scripts and popup
 chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
   console.log('[AI Governance] Message received:', message);
 
@@ -30,27 +30,258 @@ chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
       saveStats();
       updateBadge();
       break;
-    
+
     case 'PII_BLOCKED':
       stats.piiBlocked++;
       saveStats();
       updateBadge();
       break;
-    
+
     case 'VARIANT_USED':
       stats.variantsUsed++;
       saveStats();
       updateBadge();
       break;
-    
+
     case 'GET_STATS':
       sendResponse(stats);
       break;
+
+    case 'AUTH0_LOGIN':
+      handleAuth0Login(sendResponse);
+      return true; // Will respond asynchronously
+
+    case 'AUTH0_LOGOUT':
+      handleAuth0Logout(sendResponse);
+      return true;
+
+    case 'IS_AUTHENTICATED':
+      checkAuthentication(sendResponse);
+      return true;
+
+    case 'AUTH0_CALLBACK':
+      handleAuth0Callback(message, sendResponse);
+      return true;
   }
 
-  return true;
+  return false;
 });
 
+/**
+ * Handle Auth0 login initiation
+ */
+async function handleAuth0Login(sendResponse) {
+  try {
+    // Get Auth0 config
+    const config = await getConfig();
+
+    // Generate auth URL
+    const state = generateRandomString();
+    const nonce = generateRandomString();
+
+    // Store state and nonce
+    await chrome.storage.session.set({ auth0_state: state, auth0_nonce: nonce });
+
+    // Build authorization URL
+    const authUrl = new URL(`https://${config.AUTH0_DOMAIN}/authorize`);
+    authUrl.searchParams.set('client_id', config.AUTH0_CLIENT_ID);
+    authUrl.searchParams.set('response_type', 'code');
+    authUrl.searchParams.set('redirect_uri', chrome.runtime.getURL('src/auth/auth-callback.html'));
+    authUrl.searchParams.set('scope', 'openid profile email offline_access');
+    authUrl.searchParams.set('state', state);
+    authUrl.searchParams.set('nonce', nonce);
+    authUrl.searchParams.set('audience', config.AUTH0_API_AUDIENCE);
+
+    // Open Auth0 login in a popup
+    const popup = await chrome.windows.create({
+      url: authUrl.toString(),
+      type: 'popup',
+      width: 500,
+      height: 700
+    });
+
+    // Wait for popup to close and check if authenticated
+    const checkInterval = setInterval(async () => {
+      if (!popup.id) return;
+
+      try {
+        await chrome.windows.get(popup.id);
+      } catch (error) {
+        // Window closed
+        clearInterval(checkInterval);
+        const isAuth = await isAuthenticated();
+        sendResponse({
+          success: isAuth,
+          error: isAuth ? null : 'Authentication cancelled or failed'
+        });
+      }
+    }, 1000);
+  } catch (error) {
+    console.error('Auth0 login error:', error);
+    sendResponse({ success: false, error: error.message });
+  }
+}
+
+/**
+ * Handle Auth0 logout
+ */
+async function handleAuth0Logout(sendResponse) {
+  try {
+    await chrome.storage.local.remove(['auth0_token', 'auth0_token_expiry']);
+    sendResponse({ success: true });
+  } catch (error) {
+    console.error('Logout error:', error);
+    sendResponse({ success: false, error: error.message });
+  }
+}
+
+/**
+ * Check if user is authenticated
+ */
+async function checkAuthentication(sendResponse) {
+  try {
+    const isAuth = await isAuthenticated();
+    let userInfo = null;
+
+    if (isAuth) {
+      userInfo = await getUserInfo();
+    }
+
+    sendResponse({
+      authenticated: isAuth,
+      userInfo: userInfo
+    });
+  } catch (error) {
+    console.error('Authentication check error:', error);
+    sendResponse({ authenticated: false });
+  }
+}
+
+/**
+ * Handle Auth0 callback with authorization code
+ */
+async function handleAuth0Callback(message, sendResponse) {
+  try {
+    const { code, state } = message;
+
+    // Get stored state
+    const stored = await chrome.storage.session.get(['auth0_state']);
+    if (stored.auth0_state !== state) {
+      throw new Error('State mismatch - possible CSRF attack');
+    }
+
+    // Exchange code for token (in production, use backend endpoint)
+    const config = await getConfig();
+
+    const response = await fetch(`https://${config.AUTH0_DOMAIN}/oauth/token`, {
+      method: 'POST',
+      headers: {
+        'Content-Type': 'application/json'
+      },
+      body: JSON.stringify({
+        client_id: config.AUTH0_CLIENT_ID,
+        redirect_uri: chrome.runtime.getURL('src/auth/auth-callback.html'),
+        code: code,
+        grant_type: 'authorization_code'
+      })
+    });
+
+    if (!response.ok) {
+      throw new Error(`Token exchange failed: ${response.statusText}`);
+    }
+
+    const data = await response.json();
+
+    // Store token
+    const expiry = Date.now() + (data.expires_in * 1000);
+    await chrome.storage.local.set({
+      auth0_token: data.access_token,
+      auth0_token_expiry: expiry
+    });
+
+    // Clear session storage
+    await chrome.storage.session.remove(['auth0_state', 'auth0_nonce']);
+
+    sendResponse({ success: true });
+  } catch (error) {
+    console.error('Auth0 callback error:', error);
+    sendResponse({ success: false, error: error.message });
+  }
+}
+
+/**
+ * Check if user has valid Auth0 token
+ */
+async function isAuthenticated() {
+  return new Promise((resolve) => {
+    chrome.storage.local.get(['auth0_token', 'auth0_token_expiry'], (items) => {
+      const token = items.auth0_token;
+      const expiry = items.auth0_token_expiry;
+
+      if (!token || !expiry || Date.now() > expiry) {
+        resolve(false);
+      } else {
+        resolve(true);
+      }
+    });
+  });
+}
+
+/**
+ * Get user info from token
+ */
+async function getUserInfo() {
+  return new Promise((resolve) => {
+    chrome.storage.local.get(['auth0_token'], (items) => {
+      const token = items.auth0_token;
+      if (!token) {
+        resolve(null);
+        return;
+      }
+
+      try {
+        // Decode JWT
+        const parts = token.split('.');
+        if (parts.length !== 3) {
+          resolve(null);
+          return;
+        }
+
+        const payload = JSON.parse(atob(parts[1]));
+        resolve({
+          email: payload.email,
+          name: payload.name,
+          picture: payload.picture,
+          sub: payload.sub
+        });
+      } catch (error) {
+        console.error('Failed to decode token:', error);
+        resolve(null);
+      }
+    });
+  });
+}
+
+/**
+ * Get config from background
+ */
+async function getConfig() {
+  return new Promise((resolve) => {
+    // Import config from config.js
+    // In a real extension, you'd load this from config.js
+    resolve(CONFIG); // CONFIG is loaded globally from config.js
+  });
+}
+
+/**
+ * Generate random string for state/nonce
+ */
+function generateRandomString() {
+  const array = new Uint8Array(32);
+  crypto.getRandomValues(array);
+  return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
+}
+
 function saveStats() {
   chrome.storage.local.set({ stats: stats });
 }
diff --git a/browser-extension/src/content/chatgpt.js b/browser-extension/src/content/chatgpt.js
index 83fecb4..0d72ca1 100644
--- a/browser-extension/src/content/chatgpt.js
+++ b/browser-extension/src/content/chatgpt.js
@@ -1,5 +1,5 @@
 const config = {
-  API_URL: 'http://localhost:8000',
+  API_URL: 'https://blah-subsequent-personal-synthetic.trycloudflare.com',
   API_KEY: 'dev-secret-key-change-in-production',
   USER_EMAIL: 'joshini.mn@gmail.com',
   ORG_ID: 1,
@@ -178,6 +178,20 @@ class APIClient {
     });
   }
 
+  async logPromptLog(data) {
+    return this._request('/prompt-logs/', {
+      method: 'POST',
+      body: JSON.stringify({
+        user_email: this.userEmail,
+        original_prompt: data.originalPrompt,
+        chosen_variant: data.chosenVariant,
+        variants: data.variants,
+        variant_index: data.variantIndex,
+        improvement_score: data.improvementScore
+      })
+    });
+  }
+
   async createAlert(data) {
     return this._request('/alerts', {
       method: 'POST',
@@ -561,6 +575,22 @@ async function interceptPrompt(event) {
       }
     }
 
+    // ALSO log to prompt_logs for analytics (if variant was offered)
+    if (variantsOffered && variantsOffered.length > 0) {
+      try {
+        await apiClient.logPromptLog({
+          originalPrompt: originalPrompt,
+          chosenVariant: chosenPrompt,
+          variants: variantsOffered,
+          variantIndex: variantIndex,
+          improvementScore: finalScore - originalScore
+        });
+        console.log('[AI Governance] Prompt log recorded');
+      } catch (error) {
+        console.error('[AI Governance] Prompt log error:', error);
+      }
+    }
+
     // Log usage
     if (config.FEATURES.USAGE_LOGGING) {
       const promptHash = await apiClient.hashPrompt(chosenPrompt);
diff --git a/browser-extension/src/popup/popup.js b/browser-extension/src/popup/popup.js
index b8ff48d..72588b7 100644
--- a/browser-extension/src/popup/popup.js
+++ b/browser-extension/src/popup/popup.js
@@ -19,7 +19,7 @@ async function loadStats() {
 // View dashboard button
 document.getElementById('view-dashboard').addEventListener('click', () => {
   chrome.tabs.create({
-    url: 'http://localhost:3000'
+    url: 'https://surrey-tide-neutral-presence.trycloudflare.com'
   });
 });
 
@@ -30,9 +30,9 @@ document.getElementById('test-connection').addEventListener('click', async () =>
   button.disabled = true;
 
   try {
-    const response = await fetch('http://localhost:8000/health', {
+    const response = await fetch('https://blah-subsequent-personal-synthetic.trycloudflare.com/health', {
       headers: {
-        'X-API-Key': 'dev-secret-key-change-in-production'
+        'Content-Type': 'application/json'
       }
     });
 
@@ -43,13 +43,85 @@ document.getElementById('test-connection').addEventListener('click', async () =>
       alert(' Backend connection failed!\n\nStatus: ' + response.status);
     }
   } catch (error) {
-    alert(' Cannot reach backend!\n\nMake sure backend is running on http://localhost:8000\n\nError: ' + error.message);
+    alert(' Cannot reach backend!\n\nMake sure backend is running on https://blah-subsequent-personal-synthetic.trycloudflare.com\n\nError: ' + error.message);
   } finally {
     button.textContent = 'Test Backend Connection';
     button.disabled = false;
   }
 });
 
+// Login button
+document.getElementById('login-button').addEventListener('click', async () => {
+  const button = document.getElementById('login-button');
+  button.textContent = 'Logging in...';
+  button.disabled = true;
+
+  try {
+    // Send message to background script to trigger Auth0 login
+    const result = await chrome.runtime.sendMessage({ type: 'AUTH0_LOGIN' });
+
+    if (result.success) {
+      alert(' Login successful!\n\nYou can now use the extension.');
+      loadStats();
+    } else {
+      alert(' Login failed!\n\nError: ' + result.error);
+    }
+  } catch (error) {
+    alert(' Login error!\n\nError: ' + error.message);
+  } finally {
+    button.textContent = 'Login with Auth0';
+    button.disabled = false;
+  }
+});
+
+// Logout button
+document.getElementById('logout-button').addEventListener('click', async () => {
+  const button = document.getElementById('logout-button');
+  button.textContent = 'Logging out...';
+  button.disabled = true;
+
+  try {
+    // Send message to background script to trigger logout
+    await chrome.runtime.sendMessage({ type: 'AUTH0_LOGOUT' });
+    alert(' Logged out successfully!');
+    updateAuthUI();
+    loadStats();
+  } catch (error) {
+    alert(' Logout error!\n\nError: ' + error.message);
+  } finally {
+    button.textContent = 'Logout';
+    button.disabled = false;
+  }
+});
+
+// Update UI based on authentication status
+async function updateAuthUI() {
+  try {
+    const isAuthenticated = await chrome.runtime.sendMessage({ type: 'IS_AUTHENTICATED' });
+    const loginButton = document.getElementById('login-button');
+    const logoutButton = document.getElementById('logout-button');
+    const userInfo = document.getElementById('user-info');
+
+    if (isAuthenticated.authenticated) {
+      loginButton.style.display = 'none';
+      logoutButton.style.display = 'block';
+      if (isAuthenticated.userInfo) {
+        userInfo.textContent = `Logged in as: ${isAuthenticated.userInfo.email}`;
+        userInfo.style.display = 'block';
+      }
+    } else {
+      loginButton.style.display = 'block';
+      logoutButton.style.display = 'none';
+      userInfo.style.display = 'none';
+    }
+  } catch (error) {
+    console.error('Failed to update auth UI:', error);
+  }
+}
+
+// Update auth UI on load
+updateAuthUI();
+
 // Settings link
 document.getElementById('settings-link').addEventListener('click', (e) => {
   e.preventDefault();
diff --git a/browser-extension/src/shared/api-client.js b/browser-extension/src/shared/api-client.js
index d040562..c5e8dc5 100644
--- a/browser-extension/src/shared/api-client.js
+++ b/browser-extension/src/shared/api-client.js
@@ -1,25 +1,31 @@
 /**
  * API Client for communicating with backend
- * Handles all HTTP requests to the governance backend
+ * Handles all HTTP requests to the governance backend using Auth0 JWT
  */
 
 class APIClient {
-  constructor(config) {
+  constructor(config, auth0Client) {
     this.baseURL = config.API_URL;
-    this.apiKey = config.API_KEY;
-    this.userEmail = config.USER_EMAIL;
+    this.auth0Client = auth0Client;
   }
 
   /**
-   * Make authenticated request to backend
+   * Make authenticated request to backend with Auth0 JWT
    * @private
    */
   async _request(endpoint, options = {}) {
     const url = `${this.baseURL}${endpoint}`;
-    
+
+    // Get Auth0 JWT token
+    const token = await this.auth0Client.getToken();
+
+    if (!token) {
+      throw new Error('Not authenticated. Please login first.');
+    }
+
     const headers = {
       'Content-Type': 'application/json',
-      'X-API-Key': this.apiKey,
+      'Authorization': `Bearer ${token}`,
       ...options.headers
     };
 
@@ -29,6 +35,11 @@ class APIClient {
     });
 
     if (!response.ok) {
+      if (response.status === 401) {
+        // Token expired or invalid
+        await this.auth0Client.clearToken();
+        throw new Error('Authentication expired. Please login again.');
+      }
       throw new Error(`API request failed: ${response.status} ${response.statusText}`);
     }
 
@@ -37,13 +48,13 @@ class APIClient {
 
   /**
    * Log AI tool usage
+   * User email is extracted from JWT token
    * @param {Object} data - Usage data
    */
   async logUsage(data) {
     return this._request('/usage-logs/', {
       method: 'POST',
       body: JSON.stringify({
-        user_email: this.userEmail,
         tool: data.tool,
         prompt_hash: data.promptHash,
         risk_level: data.riskLevel || 'low'
@@ -68,30 +79,37 @@ class APIClient {
   }
 
   /**
-   * Log which prompt variant user chose
-   * @param {Object} data - Prompt selection data
+   * Log prompt history entry
+   * User email is extracted from JWT token
+   * @param {Object} data - Prompt history data
    */
-  async logPromptChoice(data) {
-    return this._request('/prompt-variants/log', {
+  async logPromptHistory(data) {
+    return this._request('/prompt-history/', {
       method: 'POST',
       body: JSON.stringify({
-        user_email: this.userEmail,
         original_prompt: data.originalPrompt,
-        chosen_variant: data.chosenVariant,
-        variants: data.variants
+        final_prompt: data.finalPrompt,
+        tool: data.tool,
+        variants_offered: data.variantsOffered,
+        variant_selected: data.variantSelected,
+        original_score: data.originalScore,
+        final_score: data.finalScore,
+        had_pii: data.hadPII,
+        pii_types: data.piiTypes,
+        session_id: data.sessionId
       })
     });
   }
 
   /**
    * Create compliance alert
+   * User email is extracted from JWT token
    * @param {Object} data - Alert data
    */
   async createAlert(data) {
     return this._request('/alerts', {
       method: 'POST',
       body: JSON.stringify({
-        user_email: this.userEmail,
         violation_type: data.violationType,
         details: data.details
       })
diff --git a/dashboard/.env.example b/dashboard/.env.example
index 8d3c8b1..95567c5 100644
--- a/dashboard/.env.example
+++ b/dashboard/.env.example
@@ -1,3 +1,7 @@
-# Backend API Configuration
-VITE_API_URL=http://localhost:8000
-VITE_API_KEY=dev-secret-key-change-in-production
+VITE_AUTH0_DOMAIN=dev-y75lecimhanaeqy7.us.auth0.com
+VITE_AUTH0_CLIENT_ID=b2Q5VZ2pv4Ve8YralLn1dUtAHeEnpJGl
+VITE_AUTH0_AUDIENCE=https://blah-subsequent-personal-synthetic.trycloudflare.com
+VITE_API_URL=https://blah-subsequent-personal-synthetic.trycloudflare.com
+VITE_AUTH0_REDIRECT_URI=https://keen-lenses-sunny-corporations.trycloudflare.com
+VITE_HMR_HOST=surrey-tide-neutral-presence.trycloudflare.com
+VITE_HMR_CLIENT_PORT=443
\ No newline at end of file
diff --git a/dashboard/README.md b/dashboard/README.md
index da1447b..5cfa9f6 100644
--- a/dashboard/README.md
+++ b/dashboard/README.md
@@ -22,7 +22,7 @@ React-based admin dashboard for monitoring and controlling enterprise AI usage.
 ## Prerequisites
 
 - Node.js 18+ and npm
-- Backend API running on `http://localhost:8000`
+- Backend API running on `https://blah-subsequent-personal-synthetic.trycloudflare.com`
 
 ## Setup Instructions
 
@@ -44,7 +44,7 @@ cp .env.example .env
 
 **`.env` file:**
 ```env
-VITE_API_URL=http://localhost:8000
+VITE_API_URL=https://blah-subsequent-personal-synthetic.trycloudflare.com
 VITE_API_KEY=dev-secret-key-change-in-production
 ```
 
@@ -54,7 +54,7 @@ VITE_API_KEY=dev-secret-key-change-in-production
 npm run dev
 ```
 
-Dashboard will be available at `http://localhost:3000`
+Dashboard will be available at `https://surrey-tide-neutral-presence.trycloudflare.com`
 
 ### 4. Build for Production
 
@@ -113,7 +113,7 @@ All requests include the API key in the `X-API-Key` header.
 
 1. Start backend: `cd ../backend && docker-compose up`
 2. Start dashboard: `npm run dev`
-3. Access at `http://localhost:3000`
+3. Access at `https://surrey-tide-neutral-presence.trycloudflare.com`
 
 ### Adding New Pages
 
@@ -128,7 +128,7 @@ Edit `src/services/api.js` to add/modify API endpoints.
 ## Troubleshooting
 
 **CORS errors:**
-- Ensure backend `ALLOWED_ORIGINS` includes `http://localhost:3000`
+- Ensure backend `ALLOWED_ORIGINS` includes `https://surrey-tide-neutral-presence.trycloudflare.com`
 - Check backend is running
 
 **API key errors:**
diff --git a/dashboard/package.json b/dashboard/package.json
index 6e820ae..1a0ba00 100644
--- a/dashboard/package.json
+++ b/dashboard/package.json
@@ -22,6 +22,9 @@
     "@types/react": "^18.2.37",
     "@types/react-dom": "^18.2.15",
     "@vitejs/plugin-react": "^4.2.0",
+    "autoprefixer": "^10.4.22",
+    "postcss": "^8.5.6",
+    "tailwindcss": "^4.1.17",
     "vite": "^5.0.0"
   }
 }
diff --git a/dashboard/src/App.jsx b/dashboard/src/App.jsx
index 3e74b1c..f7ee4d4 100644
--- a/dashboard/src/App.jsx
+++ b/dashboard/src/App.jsx
@@ -1,5 +1,6 @@
 import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom'
-import { AuthProvider } from './contexts/AuthContext'
+import { AuthProvider, useAuth } from './contexts/AuthContext'
+import { ApiProvider } from './components/ApiProvider'
 import Layout from './components/Layout'
 import Dashboard from './pages/Dashboard'
 import UsageAnalytics from './pages/UsageAnalytics'
@@ -8,24 +9,75 @@ import PromptImprovements from './pages/PromptImprovements'
 import Policies from './pages/Policies'
 import Login from './pages/Login'
 import PromptHistory from './pages/PromptHistory'
+import RoleSetup from './pages/RoleSetup'
+
+function ProtectedRoute({ children }) {
+  const { isAuthenticated, isLoading, userProfile, loading } = useAuth();
+
+  // Wait for both Auth0 and user profile to load
+  if (isLoading || loading) {
+    return (
+      <div className="min-h-screen bg-gray-900 flex items-center justify-center">
+        <div className="text-white">Loading...</div>
+      </div>
+    );
+  }
+
+  // Not authenticated  go to login
+  if (!isAuthenticated) {
+    return <Navigate to="/login" replace />;
+  }
+
+  // Authenticated but no role set  go to role setup
+  // Skip this check if already on role-setup page
+  if (!userProfile?.role && window.location.pathname !== '/role-setup') {
+    return <Navigate to="/role-setup" replace />;
+  }
+
+  return children;
+}
 
 function App() {
   return (
     <AuthProvider>
-      <BrowserRouter>
-        <Routes>
-          <Route path="/login" element={<Login />} />
-          <Route path="/" element={<Layout />}>
-            <Route index element={<Navigate to="/dashboard" replace />} />
-            <Route path="dashboard" element={<Dashboard />} />
-            <Route path="usage" element={<UsageAnalytics />} />
-            <Route path="alerts" element={<ComplianceAlerts />} />
-            <Route path="prompts" element={<PromptImprovements />} />
-            <Route path="policies" element={<Policies />} />
-            <Route path="history" element={<PromptHistory />} />
-          </Route>
-        </Routes>
-      </BrowserRouter>
+      <ApiProvider>
+        <BrowserRouter>
+          <Routes>
+            {/* Public Route */}
+            <Route path="/login" element={<Login />} />
+
+            {/* Role Setup (Protected but before full access) */}
+            <Route 
+              path="/role-setup" 
+              element={
+                <ProtectedRoute>
+                  <RoleSetup />
+                </ProtectedRoute>
+              } 
+            />
+
+            {/* Protected Routes (Require Auth + Role) */}
+            <Route
+              path="/"
+              element={
+                <ProtectedRoute>
+                  <Layout />
+                </ProtectedRoute>
+              }
+            >
+              {/* Default redirect to dashboard */}
+              <Route index element={<Navigate to="/dashboard" replace />} />
+
+              <Route path="dashboard" element={<Dashboard />} />
+              <Route path="usage" element={<UsageAnalytics />} />
+              <Route path="alerts" element={<ComplianceAlerts />} />
+              <Route path="prompts" element={<PromptImprovements />} />
+              <Route path="policies" element={<Policies />} />
+              <Route path="history" element={<PromptHistory />} />
+            </Route>
+          </Routes>
+        </BrowserRouter>
+      </ApiProvider>
     </AuthProvider>
   )
 }
diff --git a/dashboard/src/components/Layout.jsx b/dashboard/src/components/Layout.jsx
index fab04a8..c25c13b 100644
--- a/dashboard/src/components/Layout.jsx
+++ b/dashboard/src/components/Layout.jsx
@@ -1,25 +1,52 @@
-import { Outlet, NavLink, Navigate } from 'react-router-dom'
-import { LayoutDashboard, BarChart3, AlertTriangle, Lightbulb, Shield, LogOut } from 'lucide-react'
+import { Outlet, NavLink } from 'react-router-dom'
+import { LayoutDashboard, BarChart3, AlertTriangle, Lightbulb, Shield, LogOut, History } from 'lucide-react'
 import { useAuth } from '../contexts/AuthContext'
 
 function Layout() {
-  const { isAuthenticated, user, logout } = useAuth();
+  const { user, userProfile, logout, isSecurityTeam, isTeamLead, isEmployee } = useAuth();
 
-  if (!isAuthenticated) {
-    return <Navigate to="/login" replace />;
-  }
+  const getRoleBadge = () => {
+    const role = userProfile?.role;
+    
+    const badges = {
+      security_team: { 
+        label: 'Security Team', 
+        color: 'bg-red-100 text-red-800 border-red-300',
+        icon: ''
+      },
+      team_lead: { 
+        label: 'Team Lead', 
+        color: 'bg-blue-100 text-blue-800 border-blue-300',
+        icon: ''
+      },
+      employee: { 
+        label: 'Employee', 
+        color: 'bg-gray-100 text-gray-800 border-gray-300',
+        icon: ''
+      }
+    };
+    
+    return badges[role] || badges.employee;
+  };
+
+  const badge = getRoleBadge();
 
   return (
     <div className="dashboard-container">
       <nav className="sidebar">
+        {/* App Title */}
         <div style={{ marginBottom: '40px' }}>
-          <h1 style={{ fontSize: '24px', fontWeight: '700', marginBottom: '8px' }}>
+          <h1 style={{ fontSize: '24px', fontWeight: '700', marginBottom: '8px', color: 'white' }}>
             AI Governance
           </h1>
-          <p style={{ color: '#888', fontSize: '14px' }}>Enterprise Control Center</p>
+          <p style={{ color: '#888', fontSize: '14px' }}>
+            {isSecurityTeam() ? 'Security Control Center' : 
+             isTeamLead() ? 'Team Dashboard' : 
+             'Personal Dashboard'}
+          </p>
         </div>
 
-        {/* User Info */}
+        {/* User Info with Role Badge */}
         <div style={{
           padding: '12px',
           background: '#2a2a2a',
@@ -28,39 +55,53 @@ function Layout() {
         }}>
           <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
             <img 
-              src={user.picture} 
-              alt={user.name}
+              src={user?.picture || `https://ui-avatars.com/api/?name=${encodeURIComponent(user?.name || 'User')}&background=4299e1&color=fff`}
+              alt={user?.name || 'User'}
               style={{
                 width: '40px',
                 height: '40px',
-                borderRadius: '50%'
+                borderRadius: '50%',
+                border: '2px solid #4299e1'
               }}
             />
             <div style={{ flex: 1, overflow: 'hidden' }}>
               <div style={{ fontSize: '14px', fontWeight: '600', color: 'white' }}>
-                {user.name}
+                {user?.name || 'User'}
               </div>
               <div style={{ fontSize: '12px', color: '#888', overflow: 'hidden', textOverflow: 'ellipsis' }}>
-                {user.email}
+                {user?.email}
+              </div>
+              <div style={{ marginTop: '4px' }}>
+                <span className={`inline-flex items-center gap-1 text-xs px-2 py-1 rounded border ${badge.color}`}>
+                  <span>{badge.icon}</span>
+                  <span>{badge.label}</span>
+                </span>
               </div>
             </div>
           </div>
         </div>
         
+        {/* Navigation Links */}
         <div>
           <NavLink to="/dashboard" className="nav-link">
             <LayoutDashboard size={20} />
             Dashboard
+            {isSecurityTeam() && <span className="text-xs text-gray-400 ml-auto">All</span>}
+            {isTeamLead() && <span className="text-xs text-gray-400 ml-auto">Team</span>}
           </NavLink>
           
           <NavLink to="/usage" className="nav-link">
             <BarChart3 size={20} />
             Usage Analytics
+            {isSecurityTeam() && <span className="text-xs text-gray-400 ml-auto">All</span>}
+            {isTeamLead() && <span className="text-xs text-gray-400 ml-auto">Team</span>}
           </NavLink>
           
           <NavLink to="/alerts" className="nav-link">
             <AlertTriangle size={20} />
             Compliance Alerts
+            {isSecurityTeam() && <span className="text-xs text-gray-400 ml-auto">All</span>}
+            {isTeamLead() && <span className="text-xs text-gray-400 ml-auto">Team</span>}
           </NavLink>
           
           <NavLink to="/prompts" className="nav-link">
@@ -71,11 +112,43 @@ function Layout() {
           <NavLink to="/policies" className="nav-link">
             <Shield size={20} />
             Policies
+            {isSecurityTeam() && <span className="text-xs text-gray-400 ml-auto">Manage</span>}
           </NavLink>
-          <NavLink to="/history" className="nav-link"> <Shield size={20} /> Prompt History</NavLink>
+          
+          <NavLink to="/history" className="nav-link">
+            <History size={20} />
+            Prompt History
+            {isSecurityTeam() && <span className="text-xs text-gray-400 ml-auto">All</span>}
+            {isTeamLead() && <span className="text-xs text-gray-400 ml-auto">Team</span>}
+          </NavLink>
+
+          {/* Role Info Section (Collapsible) */}
+          {userProfile && (
+            <div style={{
+              marginTop: '20px',
+              padding: '12px',
+              background: '#1a1a1a',
+              borderRadius: '8px',
+              fontSize: '12px'
+            }}>
+              <div style={{ color: '#666', marginBottom: '4px' }}>Access Level</div>
+              <div style={{ color: '#aaa' }}>
+                {isSecurityTeam() && 'Organization-wide access'}
+                {isTeamLead() && 'Team-level access'}
+                {isEmployee() && 'Personal data only'}
+              </div>
+              {userProfile.team_id && (
+                <div style={{ marginTop: '8px' }}>
+                  <div style={{ color: '#666', marginBottom: '4px' }}>Team</div>
+                  <div style={{ color: '#aaa' }}>Team #{userProfile.team_id}</div>
+                </div>
+              )}
+            </div>
+          )}
+          
           {/* Logout */}
           <button
-            onClick={logout}
+            onClick={() => logout({ returnTo: window.location.origin })}
             className="nav-link"
             style={{
               width: '100%',
@@ -84,7 +157,10 @@ function Layout() {
               cursor: 'pointer',
               marginTop: '20px',
               color: '#ccc',
-              textAlign: 'left'
+              textAlign: 'left',
+              display: 'flex',
+              alignItems: 'center',
+              gap: '12px'
             }}
           >
             <LogOut size={20} />
diff --git a/dashboard/src/contexts/AuthContext.jsx b/dashboard/src/contexts/AuthContext.jsx
index 19aa0d6..a9b7549 100644
--- a/dashboard/src/contexts/AuthContext.jsx
+++ b/dashboard/src/contexts/AuthContext.jsx
@@ -1,66 +1,142 @@
-/**
- * Authentication Context using Auth0
- * Handles SSO login/logout
- */
-import { createContext, useContext } from 'react';
+import { createContext, useContext, useEffect, useState } from 'react';
 import { Auth0Provider, useAuth0 } from '@auth0/auth0-react';
+import api from '../services/api';
 
 const AuthContext = createContext();
 
 export function AuthProvider({ children }) {
-  // For POC, using mock auth
-  // In production, use real Auth0 config
-  
-  const mockAuth = {
-    isAuthenticated: true,
-    user: {
-      email: localStorage.getItem('user_email') || 'demo@company.com',
-      name: localStorage.getItem('user_name') || 'Demo User',
-      picture: 'https://ui-avatars.com/api/?name=Demo+User'
-    },
-    loginWithRedirect: () => {
-      const email = prompt('Enter your email:');
-      const name = prompt('Enter your name:');
-      if (email && name) {
-        localStorage.setItem('user_email', email);
-        localStorage.setItem('user_name', name);
-        window.location.reload();
-      }
-    },
-    logout: () => {
-      localStorage.removeItem('user_email');
-      localStorage.removeItem('user_name');
-      window.location.reload();
-    }
-  };
+  // Load Auth0 configuration from environment variables
+  const auth0Domain = import.meta.env.VITE_AUTH0_DOMAIN || "dev-y75lecimhanaeqy7.us.auth0.com"
+  const auth0ClientId = import.meta.env.VITE_AUTH0_CLIENT_ID || "b2Q5VZ2pv4Ve8YralLn1dUtAHeEnpJGl"
+  const auth0Audience = import.meta.env.VITE_AUTH0_AUDIENCE || "https://blah-subsequent-personal-synthetic.trycloudflare.com"
+  const auth0RedirectUri = import.meta.env.VITE_AUTH0_REDIRECT_URI || window.location.origin
 
   return (
-    <AuthContext.Provider value={mockAuth}>
-      {children}
-    </AuthContext.Provider>
+    <Auth0Provider
+      domain={auth0Domain}
+      clientId={auth0ClientId}
+      authorizationParams={{
+        redirect_uri: auth0RedirectUri,
+        audience: auth0Audience,
+      }}
+      onRedirectCallback={(appState) => {
+        // After Auth0 login, check if user needs role setup
+        window.history.replaceState({}, document.title, appState?.returnTo || "/dashboard");
+      }}
+    >
+      <AuthContextProvider>
+        {children}
+      </AuthContextProvider>
+    </Auth0Provider>
   );
 }
 
-export function useAuth() {
-  return useContext(AuthContext);
-}
+function AuthContextProvider({ children }) {
+  const auth0 = useAuth0();
+  const [userProfile, setUserProfile] = useState(null);
+  const [loading, setLoading] = useState(true);
+
+  useEffect(() => {
+    async function loadUserProfile() {
+      if (auth0.isAuthenticated && !auth0.isLoading) {
+        try {
+          // Get access token
+          const token = await auth0.getAccessTokenSilently();
+          
+          // Set token in API client
+          api.setAuthToken(token);
+          
+          // Fetch user profile from backend (includes role, team, org)
+          const response = await api.get('/users/me');
+          setUserProfile(response.data);
+          
+          console.log('[Auth] User profile loaded:', {
+            email: response.data.email,
+            role: response.data.role,
+            team_id: response.data.team_id
+          });
+        } catch (error) {
+          console.error('[Auth] Failed to load user profile:', error);
+          // User might not exist in DB yet - will be created on first API call
+        } finally {
+          setLoading(false);
+        }
+      } else if (!auth0.isLoading) {
+        setLoading(false);
+      }
+    }
+
+    loadUserProfile();
+  }, [auth0.isAuthenticated, auth0.isLoading]);
+
+  // Helper functions for role checking
+  const hasRole = (role) => {
+    if (!userProfile) return false;
+    return userProfile.role === role;
+  };
+
+  const isSecurityTeam = () => hasRole('security_team');
+  const isTeamLead = () => hasRole('team_lead');
+  const isEmployee = () => hasRole('employee');
+
+  const canViewAllTeams = () => isSecurityTeam();
+  const canManageTeam = () => isSecurityTeam() || isTeamLead();
+
+  // Update role (for POC/testing - allows user to select role on first login)
+  const updateRole = async (newRole) => {
+    try {
+      const token = await auth0.getAccessTokenSilently();
+      api.setAuthToken(token);
+      
+      const response = await api.patch('/users/me/role', { new_role: newRole });
+      setUserProfile(response.data);
+      
+      console.log('[Auth] Role updated to:', newRole);
+      return response.data;
+    } catch (error) {
+      console.error('[Auth] Failed to update role:', error);
+      throw error;
+    }
+  };
+
+  const value = {
+    // Auth0 properties
+    ...auth0,
+    
+    // User profile from database
+    userProfile,
+    
+    // Combined loading state
+    loading: auth0.isLoading || loading,
+    
+    // Role checking helpers
+    hasRole,
+    isSecurityTeam,
+    isTeamLead,
+    isEmployee,
+    canViewAllTeams,
+    canManageTeam,
+    
+    // Role management
+    updateRole,
+    
+    // Convenience accessors
+    userRole: userProfile?.role,
+    userTeam: userProfile?.team_id,
+    userOrg: userProfile?.org_id,
+  };
 
-// For production with real Auth0:
-/*
-export function AuthProvider({ children }) {
   return (
-    <Auth0Provider
-      domain="your-tenant.auth0.com"
-      clientId="your-client-id"
-      redirectUri={window.location.origin}
-      audience="https://your-api.com"
-    >
+    <AuthContext.Provider value={value}>
       {children}
-    </Auth0Provider>
+    </AuthContext.Provider>
   );
 }
 
 export function useAuth() {
-  return useAuth0();
-}
-*/
\ No newline at end of file
+  const context = useContext(AuthContext);
+  if (!context) {
+    throw new Error('useAuth must be used within AuthProvider');
+  }
+  return context;
+}
\ No newline at end of file
diff --git a/dashboard/src/index.css b/dashboard/src/index.css
index f2e0f58..5758e6d 100644
--- a/dashboard/src/index.css
+++ b/dashboard/src/index.css
@@ -1,3 +1,7 @@
+@tailwind base;
+@tailwind components;
+@tailwind utilities;
+
 * {
   margin: 0;
   padding: 0;
diff --git a/dashboard/src/pages/Login.jsx b/dashboard/src/pages/Login.jsx
index a87570b..8f14e23 100644
--- a/dashboard/src/pages/Login.jsx
+++ b/dashboard/src/pages/Login.jsx
@@ -3,12 +3,12 @@ import { useNavigate } from 'react-router-dom';
 import { useAuth } from '../contexts/AuthContext';
 
 function Login() {
-  const { isAuthenticated, loginWithRedirect, user } = useAuth();
+  const { isAuthenticated, loginWithRedirect } = useAuth();
   const navigate = useNavigate();
 
   useEffect(() => {
     if (isAuthenticated) {
-      navigate('/dashboard');
+      navigate('/dashboard', { replace: true });
     }
   }, [isAuthenticated, navigate]);
 
@@ -36,7 +36,7 @@ function Login() {
         </p>
         
         <button
-          onClick={loginWithRedirect}
+          onClick={() => loginWithRedirect()}
           style={{
             width: '100%',
             padding: '14px',
@@ -60,4 +60,4 @@ function Login() {
   );
 }
 
-export default Login;
\ No newline at end of file
+export default Login;
diff --git a/dashboard/src/pages/PromptHistory.jsx b/dashboard/src/pages/PromptHistory.jsx
index fd6962e..4164199 100644
--- a/dashboard/src/pages/PromptHistory.jsx
+++ b/dashboard/src/pages/PromptHistory.jsx
@@ -6,8 +6,8 @@
  */
 
 import { useState, useEffect } from 'react';
-import { Search, Filter, Calendar, TrendingUp, AlertCircle, Check, X } from 'lucide-react';
-import api from '../services/api';
+import { Search, Filter, Calendar, TrendingUp, AlertCircle, Check, X, Trash2 } from 'lucide-react';
+import { promptHistoryApi } from '../services/api';
 
 function PromptHistory() {
   const [history, setHistory] = useState([]);
@@ -31,18 +31,15 @@ function PromptHistory() {
   const fetchHistory = async () => {
     try {
       setLoading(true);
-      const params = new URLSearchParams({
+      const response = await promptHistoryApi.getHistory({
         days: daysFilter,
         page: page,
-        page_size: 20
+        page_size: 20,
+        tool: toolFilter || undefined,
+        had_pii: piiFilter ? (piiFilter === 'true') : undefined
       });
-      
-      if (toolFilter) params.append('tool', toolFilter);
-      if (piiFilter) params.append('had_pii', piiFilter);
-      
-      const response = await api.get(`/prompt-history/?${params}`);
-      setHistory(response.data.items);
-      setTotalPages(Math.ceil(response.data.total / 20));
+      setHistory(response.items);
+      setTotalPages(Math.ceil(response.total / 20));
     } catch (error) {
       console.error('Failed to fetch history:', error);
     } finally {
@@ -52,8 +49,10 @@ function PromptHistory() {
 
   const fetchStats = async () => {
     try {
-      const response = await api.get(`/prompt-history/stats?days=${daysFilter}`);
-      setStats(response.data);
+      const response = await promptHistoryApi.getStats({
+        days: daysFilter
+      });
+      setStats(response);
     } catch (error) {
       console.error('Failed to fetch stats:', error);
     }
@@ -71,6 +70,20 @@ function PromptHistory() {
     return '#ef4444'; // red
   };
 
+  const handleDeletePrompt = async (promptId) => {
+    if (!window.confirm('Are you sure you want to delete this prompt history entry? This action cannot be undone.')) {
+      return;
+    }
+
+    try {
+      await promptHistoryApi.delete(promptId);
+      setHistory(history.filter(h => h.id !== promptId));
+      setSelectedPrompt(null);
+    } catch (error) {
+      alert('Failed to delete prompt history: ' + error.message);
+    }
+  };
+
   return (
     <div style={{ padding: '24px', maxWidth: '1400px', margin: '0 auto' }}>
       {/* Header */}
@@ -510,6 +523,51 @@ function PromptHistory() {
                 <strong style={{ color: '#dc2626' }}> PII Detected:</strong> {selectedPrompt.pii_types.join(', ')}
               </div>
             )}
+
+            {/* Action Buttons */}
+            <div style={{
+              marginTop: '24px',
+              paddingTop: '16px',
+              borderTop: '1px solid #e5e7eb',
+              display: 'flex',
+              gap: '12px',
+              justifyContent: 'flex-end'
+            }}>
+              <button
+                onClick={() => setSelectedPrompt(null)}
+                style={{
+                  padding: '10px 16px',
+                  background: '#e5e7eb',
+                  color: '#374151',
+                  border: 'none',
+                  borderRadius: '6px',
+                  cursor: 'pointer',
+                  fontSize: '14px',
+                  fontWeight: '500'
+                }}
+              >
+                Close
+              </button>
+              <button
+                onClick={() => handleDeletePrompt(selectedPrompt.id)}
+                style={{
+                  padding: '10px 16px',
+                  background: '#ef4444',
+                  color: 'white',
+                  border: 'none',
+                  borderRadius: '6px',
+                  cursor: 'pointer',
+                  fontSize: '14px',
+                  fontWeight: '500',
+                  display: 'flex',
+                  alignItems: 'center',
+                  gap: '8px'
+                }}
+              >
+                <Trash2 size={16} />
+                Delete Entry
+              </button>
+            </div>
           </div>
         </div>
       )}
diff --git a/dashboard/src/services/api.js b/dashboard/src/services/api.js
index 67a7166..4649b7b 100644
--- a/dashboard/src/services/api.js
+++ b/dashboard/src/services/api.js
@@ -1,94 +1,231 @@
 /**
  * API service for communicating with backend
- * All API calls go through this service
+ * All API calls go through this service with Auth0 JWT authentication
  */
 import axios from 'axios'
 
-const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:8000'
-const API_KEY = import.meta.env.VITE_API_KEY || 'dev-secret-key-change-in-production'
+const API_URL = import.meta.env.VITE_API_URL || 'https://blah-subsequent-personal-synthetic.trycloudflare.com'
 
 // Create axios instance with default config
 const api = axios.create({
   baseURL: API_URL,
   headers: {
     'Content-Type': 'application/json',
-    'X-API-Key': API_KEY
   }
-})
+});
+
+// Store for Auth0 token getter (set by ApiProvider wrapper component)
+let getAccessTokenFn = null;
+
+/**
+ * Set the Auth0 token getter function
+ * Called by ApiProvider component wrapper
+ * @param {Function} tokenFn - Async function that returns Auth0 access token
+ */
+export function setAccessTokenGetter(tokenFn) {
+  getAccessTokenFn = tokenFn;
+}
+
+// Add auth token to requests
+api.interceptors.request.use(async (config) => {
+  if (getAccessTokenFn) {
+    try {
+      const token = await getAccessTokenFn();
+      if (token) {
+        config.headers.Authorization = `Bearer ${token}`;
+      }
+    } catch (error) {
+      console.error('[API] Failed to get access token:', error);
+    }
+  }
+  return config;
+});
+
+// Response interceptor for error handling
+api.interceptors.response.use(
+  (response) => response,
+  (error) => {
+    if (error.response?.status === 401) {
+      console.error('[API] Unauthorized - token may be expired');
+      // Could trigger re-auth here
+    } else if (error.response?.status === 403) {
+      console.error('[API] Forbidden - insufficient permissions');
+    }
+    return Promise.reject(error);
+  }
+);
+
+// Set auth token directly (alternative to using getter)
+api.setAuthToken = (token) => {
+  if (token) {
+    api.defaults.headers.common['Authorization'] = `Bearer ${token}`;
+  } else {
+    delete api.defaults.headers.common['Authorization'];
+  }
+};
+
+// Users API
+export const usersApi = {
+  // Get current user profile
+  getCurrentUser: async () => {
+    const response = await api.get('/users/me');
+    return response.data;
+  },
+
+  // Update current user's role (POC only)
+  updateMyRole: async (role) => {
+    const response = await api.patch('/users/me/role', { new_role: role });
+    return response.data;
+  },
+
+  // Update another user's role (security team only)
+  updateUserRole: async (userId, role) => {
+    const response = await api.patch(`/users/${userId}/role?new_role=${encodeURIComponent(role)}`);
+    return response.data;
+  },
+
+  // Get accessible user IDs for filtering
+  getAccessibleUserIds: async () => {
+    const response = await api.get('/users/accessible-users/ids');
+    return response.data;
+  },
+
+  // List users (filtered by permissions)
+  listUsers: async (teamId = null) => {
+    const params = teamId ? `?team_id=${teamId}` : '';
+    const response = await api.get(`/users/${params}`);
+    return response.data;
+  },
+
+  // Get teams (team leads and security only)
+  getTeams: async () => {
+    const response = await api.get('/users/teams');
+    return response.data;
+  },
+
+  // Get team members
+  getTeamMembers: async (teamId) => {
+    const response = await api.get(`/users/team/${teamId}/members`);
+    return response.data;
+  }
+};
 
 // Usage Logs API
 export const usageApi = {
-  // Get usage logs with filters
+  // Get usage logs with filters (role-based access)
   getLogs: async (filters = {}) => {
-    const params = new URLSearchParams()
-    if (filters.user_email) params.append('user_email', filters.user_email)
-    if (filters.tool) params.append('tool', filters.tool)
-    if (filters.days) params.append('days', filters.days)
+    const params = new URLSearchParams();
+    if (filters.user_email) params.append('user_email', filters.user_email);
+    if (filters.tool) params.append('tool', filters.tool);
+    if (filters.days) params.append('days', filters.days);
     
-    const response = await api.get(`/usage-logs/?${params}`)
-    return response.data
+    const response = await api.get(`/usage-logs/?${params}`);
+    return response.data;
+  },
+  
+  // Get usage statistics (role-based)
+  getStats: async (days = 7) => {
+    const response = await api.get(`/usage-logs/stats?days=${days}`);
+    return response.data;
   },
   
   // Create usage log (called by extension)
   createLog: async (logData) => {
-    const response = await api.post('/usage-logs/', logData)
-    return response.data
+    const response = await api.post('/usage-logs/', logData);
+    return response.data;
   }
-}
+};
 
 // Analytics API
 export const analyticsApi = {
   // Get usage statistics
   getUsageStats: async (days = 7) => {
-    const response = await api.get(`/analytics/usage?days=${days}`)
-    return response.data
+    const response = await api.get(`/analytics/usage?days=${days}`);
+    return response.data;
   },
   
   // Get prompt improvement statistics
   getPromptStats: async (days = 7) => {
-    const response = await api.get(`/analytics/prompt-improvements?days=${days}`)
-    return response.data
+    const response = await api.get(`/analytics/prompt-improvements?days=${days}`);
+    return response.data;
   }
-}
+};
 
 // Policies API
 export const policiesApi = {
   // Get policies for an organization
   getPolicies: async (orgId = 1) => {
-    const response = await api.get(`/policies/${orgId}`)
-    return response.data
+    const response = await api.get(`/policies/${orgId}`);
+    return response.data;
   },
   
   // Create new policy
   createPolicy: async (policyData) => {
-    const response = await api.post('/policies', policyData)
-    return response.data
+    const response = await api.post('/policies', policyData);
+    return response.data;
   }
-}
+};
 
 // Alerts API
 export const alertsApi = {
   // Get alerts with filters
   getAlerts: async (filters = {}) => {
-    const params = new URLSearchParams()
-    if (filters.resolved !== undefined) params.append('resolved', filters.resolved)
-    if (filters.days) params.append('days', filters.days)
-    
-    const response = await api.get(`/alerts?${params}`)
-    return response.data
+    const params = new URLSearchParams();
+    if (filters.resolved !== undefined) params.append('resolved', filters.resolved);
+    if (filters.days) params.append('days', filters.days);
+
+    const response = await api.get(`/alerts?${params}`);
+    return response.data;
   },
-  
+
   // Create alert
   createAlert: async (alertData) => {
-    const response = await api.post('/alerts', alertData)
-    return response.data
+    const response = await api.post('/alerts', alertData);
+    return response.data;
   },
-  
+
   // Resolve alert
   resolveAlert: async (alertId) => {
-    const response = await api.patch(`/alerts/${alertId}/resolve`)
-    return response.data
+    const response = await api.patch(`/alerts/${alertId}/resolve`);
+    return response.data;
   }
-}
+};
+
+// Prompt History API
+export const promptHistoryApi = {
+  // Get prompt history with filters and pagination
+  getHistory: async (filters = {}) => {
+    const params = new URLSearchParams();
+    if (filters.tool) params.append('tool', filters.tool);
+    if (filters.had_pii !== undefined) params.append('had_pii', filters.had_pii);
+    if (filters.days) params.append('days', filters.days);
+    if (filters.page) params.append('page', filters.page);
+    if (filters.page_size) params.append('page_size', filters.page_size);
+
+    const response = await api.get(`/prompt-history/?${params}`);
+    return response.data;
+  },
+
+  // Get prompt history statistics
+  getStats: async (filters = {}) => {
+    const params = new URLSearchParams();
+    if (filters.days) params.append('days', filters.days);
+
+    const response = await api.get(`/prompt-history/stats?${params}`);
+    return response.data;
+  },
+
+  // Get specific prompt history entry
+  getById: async (historyId) => {
+    const response = await api.get(`/prompt-history/${historyId}`);
+    return response.data;
+  },
+
+  // Delete prompt history entry
+  delete: async (historyId) => {
+    const response = await api.delete(`/prompt-history/${historyId}`);
+    return response.data;
+  }
+};
 
-export default api
+export default api;
\ No newline at end of file
diff --git a/dashboard/vite.config.js b/dashboard/vite.config.js
index 62c4666..dd51dbc 100644
--- a/dashboard/vite.config.js
+++ b/dashboard/vite.config.js
@@ -1,16 +1,23 @@
 import { defineConfig } from 'vite'
 import react from '@vitejs/plugin-react'
 
-// https://vitejs.dev/config/
+const hmrConfig = { protocol: 'wss' }
+if (process.env.VITE_HMR_HOST) hmrConfig.host = process.env.VITE_HMR_HOST
+if (process.env.VITE_HMR_CLIENT_PORT) hmrConfig.clientPort = Number(process.env.VITE_HMR_CLIENT_PORT)
+
 export default defineConfig({
   plugins: [react()],
   server: {
     port: 3000,
+    host: true,
+    // allow TryCloudflare subdomains (frontend is served via trycloudflare)
+    allowedHosts: ['.trycloudflare.com'],    
+    hmr: hmrConfig,
     proxy: {
       '/api': {
-        target: 'http://localhost:8000',
+        target: 'https://blah-subsequent-personal-synthetic.trycloudflare.com',
         changeOrigin: true,
-      }
-    }
-  }
+      },
+    },
+  },
 })
